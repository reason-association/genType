// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as $$Map from "bs-platform/lib/es6/map.js";
import * as $$Set from "bs-platform/lib/es6/set.js";
import * as Sys from "bs-platform/lib/es6/sys.js";
import * as List from "bs-platform/lib/es6/list.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Bytes from "bs-platform/lib/es6/bytes.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as $$Buffer from "bs-platform/lib/es6/buffer.js";
import * as Format from "bs-platform/lib/es6/format.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Hashtbl from "bs-platform/lib/es6/hashtbl.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Caml_sys from "bs-platform/lib/es6/caml_sys.js";
import * as Filename from "bs-platform/lib/es6/filename.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";
import * as Caml_bytes from "bs-platform/lib/es6/caml_bytes.js";
import * as Caml_int32 from "bs-platform/lib/es6/caml_int32.js";
import * as Caml_int64 from "bs-platform/lib/es6/caml_int64.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_format from "bs-platform/lib/es6/caml_format.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Caml_string from "bs-platform/lib/es6/caml_string.js";
import * as Caml_primitive from "bs-platform/lib/es6/caml_primitive.js";
import * as Caml_exceptions from "bs-platform/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.js";
import * as Caml_external_polyfill from "bs-platform/lib/es6/caml_external_polyfill.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";

var Fatal_error = Caml_exceptions.create("Misc.Fatal_error");

function array_of_list_rev(param) {
  if (param) {
    var tl = param[1];
    var len = List.length(tl);
    var a = Caml_array.caml_make_vect(len + 1 | 0, param[0]);
    var _i = len - 1 | 0;
    var _param = tl;
    while(true) {
      var param$1 = _param;
      var i = _i;
      if (param$1) {
        a[i] = param$1[0];
        _param = param$1[1];
        _i = i - 1 | 0;
        continue ;
      } else {
        return a;
      }
    };
  } else {
    return /* array */[];
  }
}

function fatal_error(msg) {
  Pervasives.prerr_string(">> Fatal error: ");
  console.error(msg);
  throw Fatal_error;
}

function fatal_errorf(fmt) {
  return Format.kasprintf(fatal_error, fmt);
}

function try_finally(work, cleanup) {
  var result;
  try {
    result = Curry._1(work, /* () */0);
  }
  catch (e){
    Curry._1(cleanup, /* () */0);
    throw e;
  }
  Curry._1(cleanup, /* () */0);
  return result;
}

function set_refs(l) {
  return List.iter((function (param) {
                param[0][0] = param[1];
                return /* () */0;
              }), l);
}

function protect_refs(refs, f) {
  var backup = List.map((function (param) {
          var r = param[0];
          return /* R */[
                  r,
                  r[0]
                ];
        }), refs);
  set_refs(refs);
  var x;
  try {
    x = Curry._1(f, /* () */0);
  }
  catch (e){
    set_refs(backup);
    throw e;
  }
  set_refs(backup);
  return x;
}

function map_end(f, l1, l2) {
  if (l1) {
    return /* :: */[
            Curry._1(f, l1[0]),
            map_end(f, l1[1], l2)
          ];
  } else {
    return l2;
  }
}

function map_left_right(f, param) {
  if (param) {
    var res = Curry._1(f, param[0]);
    return /* :: */[
            res,
            map_left_right(f, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function for_all2(pred, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2 && Curry._2(pred, l1[0], l2[0])) {
        _l2 = l2[1];
        _l1 = l1[1];
        continue ;
      } else {
        return false;
      }
    } else if (l2) {
      return false;
    } else {
      return true;
    }
  };
}

function replicate_list(elem, n) {
  if (n <= 0) {
    return /* [] */0;
  } else {
    return /* :: */[
            elem,
            replicate_list(elem, n - 1 | 0)
          ];
  }
}

function list_remove(x, param) {
  if (param) {
    var tl = param[1];
    var hd = param[0];
    if (Caml_obj.caml_equal(hd, x)) {
      return tl;
    } else {
      return /* :: */[
              hd,
              list_remove(x, tl)
            ];
    }
  } else {
    return /* [] */0;
  }
}

function split_last(param) {
  if (param) {
    var tl = param[1];
    var x = param[0];
    if (tl) {
      var match = split_last(tl);
      return /* tuple */[
              /* :: */[
                x,
                match[0]
              ],
              match[1]
            ];
    } else {
      return /* tuple */[
              /* [] */0,
              x
            ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "misc.ml",
            82,
            10
          ]
        ];
  }
}

function compare(cmp, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        var c = Curry._2(cmp, l1[0], l2[0]);
        if (c !== 0) {
          return c;
        } else {
          _l2 = l2[1];
          _l1 = l1[1];
          continue ;
        }
      } else {
        return 1;
      }
    } else if (l2) {
      return -1;
    } else {
      return 0;
    }
  };
}

function equal(eq, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2 && Curry._2(eq, l1[0], l2[0])) {
        _l2 = l2[1];
        _l1 = l1[1];
        continue ;
      } else {
        return false;
      }
    } else if (l2) {
      return false;
    } else {
      return true;
    }
  };
}

function filter_map(f, l) {
  var _acc = /* [] */0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc = _acc;
    if (l$1) {
      var t = l$1[1];
      var match = Curry._1(f, l$1[0]);
      _l = t;
      if (match !== undefined) {
        _acc = /* :: */[
          Caml_option.valFromOption(match),
          acc
        ];
        continue ;
      } else {
        continue ;
      }
    } else {
      return List.rev(acc);
    }
  };
}

function map2_prefix(f, l1, l2) {
  var _acc = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var acc = _acc;
    if (l1$1) {
      if (l2$1) {
        var h = Curry._2(f, l1$1[0], l2$1[0]);
        _l2 = l2$1[1];
        _l1 = l1$1[1];
        _acc = /* :: */[
          h,
          acc
        ];
        continue ;
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "map2_prefix"
            ];
      }
    } else {
      return /* tuple */[
              List.rev(acc),
              l2$1
            ];
    }
  };
}

function some_if_all_elements_are_some(l) {
  var _acc = /* [] */0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc = _acc;
    if (l$1) {
      var match = l$1[0];
      if (match !== undefined) {
        _l = l$1[1];
        _acc = /* :: */[
          Caml_option.valFromOption(match),
          acc
        ];
        continue ;
      } else {
        return ;
      }
    } else {
      return List.rev(acc);
    }
  };
}

function split_at(n, l) {
  var _n = n;
  var _acc = /* [] */0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc = _acc;
    var n$1 = _n;
    if (n$1 === 0) {
      return /* tuple */[
              List.rev(acc),
              l$1
            ];
    } else if (l$1) {
      _l = l$1[1];
      _acc = /* :: */[
        l$1[0],
        acc
      ];
      _n = n$1 - 1 | 0;
      continue ;
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "split_at"
          ];
    }
  };
}

function equal$1(eq, o1, o2) {
  if (o1 !== undefined) {
    if (o2 !== undefined) {
      return Curry._2(eq, Caml_option.valFromOption(o1), Caml_option.valFromOption(o2));
    } else {
      return false;
    }
  } else {
    return o2 === undefined;
  }
}

function iter(f, param) {
  if (param !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(param));
  } else {
    return /* () */0;
  }
}

function map(f, param) {
  if (param !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(param)));
  }
  
}

function fold(f, a, b) {
  if (a !== undefined) {
    return Curry._2(f, Caml_option.valFromOption(a), b);
  } else {
    return b;
  }
}

function value_default(f, $$default, a) {
  if (a !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(a));
  } else {
    return $$default;
  }
}

var $$Option = {
  equal: equal$1,
  iter: iter,
  map: map,
  fold: fold,
  value_default: value_default
};

function exists2(p, a1, a2) {
  var n = a1.length;
  if (a2.length !== n) {
    Pervasives.invalid_arg("Misc.Stdlib.Array.exists2");
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    } else if (Curry._2(p, a1[i], a2[i])) {
      return true;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  };
}

var $$Array$1 = {
  exists2: exists2
};

function find_in_path(path, name) {
  if (Curry._1(Filename.is_implicit, name)) {
    var _param = path;
    while(true) {
      var param = _param;
      if (param) {
        var fullname = Filename.concat(param[0], name);
        if (Caml_external_polyfill.resolve("caml_sys_file_exists")(fullname)) {
          return fullname;
        } else {
          _param = param[1];
          continue ;
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  } else if (Caml_external_polyfill.resolve("caml_sys_file_exists")(name)) {
    return name;
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_in_path_rel(path, name) {
  var simplify = function (_s) {
    while(true) {
      var s = _s;
      var base = Curry._1(Filename.basename, s);
      var dir = Curry._1(Filename.dirname, s);
      if (dir === s) {
        return dir;
      } else if (base === Filename.current_dir_name) {
        _s = dir;
        continue ;
      } else {
        return Filename.concat(simplify(dir), base);
      }
    };
  };
  var _param = path;
  while(true) {
    var param = _param;
    if (param) {
      var fullname = simplify(Filename.concat(param[0], name));
      if (Caml_external_polyfill.resolve("caml_sys_file_exists")(fullname)) {
        return fullname;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function find_in_path_uncap(path, name) {
  var uname = $$String.uncapitalize_ascii(name);
  var _param = path;
  while(true) {
    var param = _param;
    if (param) {
      var dir = param[0];
      var fullname = Filename.concat(dir, name);
      var ufullname = Filename.concat(dir, uname);
      if (Caml_external_polyfill.resolve("caml_sys_file_exists")(ufullname)) {
        return ufullname;
      } else if (Caml_external_polyfill.resolve("caml_sys_file_exists")(fullname)) {
        return fullname;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function remove_file(filename) {
  try {
    if (Caml_external_polyfill.resolve("caml_sys_file_exists")(filename)) {
      return Caml_external_polyfill.resolve("caml_sys_remove")(filename);
    } else {
      return 0;
    }
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.sys_error) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function expand_directory(alt, s) {
  if (s.length !== 0 && Caml_string.get(s, 0) === /* "+" */43) {
    return Filename.concat(alt, $$String.sub(s, 1, s.length - 1 | 0));
  } else {
    return s;
  }
}

function create_hashtable(size, init) {
  var tbl = Hashtbl.create(undefined, size);
  List.iter((function (param) {
          return Hashtbl.add(tbl, param[0], param[1]);
        }), init);
  return tbl;
}

function copy_file(ic, oc) {
  var buff = Caml_bytes.caml_create_bytes(4096);
  var _param = /* () */0;
  while(true) {
    var n = Pervasives.input(ic, buff, 0, 4096);
    if (n === 0) {
      return /* () */0;
    } else {
      Pervasives.output(oc, buff, 0, n);
      _param = /* () */0;
      continue ;
    }
  };
}

function copy_file_chunk(ic, oc, len) {
  var buff = Caml_bytes.caml_create_bytes(4096);
  var _n = len;
  while(true) {
    var n = _n;
    if (n <= 0) {
      return /* () */0;
    } else {
      var r = Pervasives.input(ic, buff, 0, n < 4096 ? n : 4096);
      if (r === 0) {
        throw Caml_builtin_exceptions.end_of_file;
      }
      Pervasives.output(oc, buff, 0, r);
      _n = n - r | 0;
      continue ;
    }
  };
}

function string_of_file(ic) {
  var b = $$Buffer.create(65536);
  var buff = Caml_bytes.caml_create_bytes(4096);
  var _param = /* () */0;
  while(true) {
    var n = Pervasives.input(ic, buff, 0, 4096);
    if (n === 0) {
      return $$Buffer.contents(b);
    } else {
      $$Buffer.add_subbytes(b, buff, 0, n);
      _param = /* () */0;
      continue ;
    }
  };
}

function output_to_bin_file_directly(filename, fn) {
  var oc = Pervasives.open_out_bin(filename);
  var v;
  try {
    v = Curry._2(fn, filename, oc);
  }
  catch (e){
    Pervasives.close_out(oc);
    throw e;
  }
  Pervasives.close_out(oc);
  return v;
}

function output_to_file_via_temporary($staropt$star, filename, fn) {
  var mode = $staropt$star !== undefined ? $staropt$star : /* :: */[
      /* Open_text */7,
      /* [] */0
    ];
  var match = Filename.open_temp_file(mode, 438, Curry._1(Filename.dirname, filename), Curry._1(Filename.basename, filename), ".tmp");
  var oc = match[1];
  var temp_filename = match[0];
  var res;
  try {
    res = Curry._2(fn, temp_filename, oc);
  }
  catch (exn){
    Pervasives.close_out(oc);
    remove_file(temp_filename);
    throw exn;
  }
  Pervasives.close_out(oc);
  try {
    Caml_external_polyfill.resolve("caml_sys_rename")(temp_filename, filename);
    return res;
  }
  catch (exn$1){
    remove_file(temp_filename);
    throw exn$1;
  }
}

function log2(n) {
  if (n <= 1) {
    return 0;
  } else {
    return 1 + log2((n >> 1)) | 0;
  }
}

function align(n, a) {
  if (n >= 0) {
    return (n + a | 0) - 1 & (-a | 0);
  } else {
    return n & (-a | 0);
  }
}

function no_overflow_add(a, b) {
  return (a ^ b | a ^ Pervasives.lnot(a + b | 0)) < 0;
}

function no_overflow_sub(a, b) {
  return (a ^ Pervasives.lnot(b) | b ^ (a - b | 0)) < 0;
}

function no_overflow_mul(a, b) {
  if (b !== 0) {
    return Caml_int32.div(Caml_int32.imul(a, b), b) === a;
  } else {
    return false;
  }
}

function no_overflow_lsl(a, k) {
  if (0 <= k && k < Sys.word_size && (Pervasives.min_int >> k) <= a) {
    return a <= (Pervasives.max_int >> k);
  } else {
    return false;
  }
}

function cvt_int_aux(str, neg, of_string) {
  if (str.length === 0 || Caml_string.get(str, 0) === /* "-" */45) {
    return Curry._1(of_string, str);
  } else {
    return Curry._1(neg, Curry._1(of_string, "-" + str));
  }
}

function $$int(s) {
  return cvt_int_aux(s, (function (prim) {
                return -prim | 0;
              }), Caml_format.caml_int_of_string);
}

function int32(s) {
  return cvt_int_aux(s, (function (prim) {
                return -prim | 0;
              }), Caml_format.caml_int32_of_string);
}

function int64(s) {
  return cvt_int_aux(s, Caml_int64.neg, Caml_format.caml_int64_of_string);
}

function nativeint(s) {
  return cvt_int_aux(s, (function (prim) {
                return -prim;
              }), Caml_format.caml_nativeint_of_string);
}

function chop_extensions(file) {
  var dirname = Curry._1(Filename.dirname, file);
  var basename = Curry._1(Filename.basename, file);
  try {
    var pos = $$String.index(basename, /* "." */46);
    var basename$1 = $$String.sub(basename, 0, pos);
    if (Curry._1(Filename.is_implicit, file) && dirname === Filename.current_dir_name) {
      return basename$1;
    } else {
      return Filename.concat(dirname, basename$1);
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return file;
    } else {
      throw exn;
    }
  }
}

function search_substring(pat, str, start) {
  var _i = start;
  var _j = 0;
  while(true) {
    var j = _j;
    var i = _i;
    if (j >= pat.length) {
      return i;
    } else {
      if ((i + j | 0) >= str.length) {
        throw Caml_builtin_exceptions.not_found;
      }
      if (Caml_string.get(str, i + j | 0) === Caml_string.get(pat, j)) {
        _j = j + 1 | 0;
        continue ;
      } else {
        _j = 0;
        _i = i + 1 | 0;
        continue ;
      }
    }
  };
}

function replace_substring(before, after, str) {
  var search = function (_acc, _curr) {
    while(true) {
      var curr = _curr;
      var acc = _acc;
      var next;
      try {
        next = search_substring(before, str, curr);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var suffix = $$String.sub(str, curr, str.length - curr | 0);
          return List.rev(/* :: */[
                      suffix,
                      acc
                    ]);
        } else {
          throw exn;
        }
      }
      var prefix = $$String.sub(str, curr, next - curr | 0);
      _curr = next + before.length | 0;
      _acc = /* :: */[
        prefix,
        acc
      ];
      continue ;
    };
  };
  return $$String.concat(after, search(/* [] */0, 0));
}

function rev_split_words(s) {
  var split1 = function (res, _i) {
    while(true) {
      var i = _i;
      if (i >= s.length) {
        return res;
      } else {
        var match = Caml_string.get(s, i);
        var switcher = match - 9 | 0;
        if (switcher > 4 || switcher < 0) {
          if (switcher !== 23) {
            return split2(res, i, i + 1 | 0);
          } else {
            _i = i + 1 | 0;
            continue ;
          }
        } else if (switcher === 3 || switcher === 2) {
          return split2(res, i, i + 1 | 0);
        } else {
          _i = i + 1 | 0;
          continue ;
        }
      }
    };
  };
  var split2 = function (res, i, _j) {
    while(true) {
      var j = _j;
      if (j >= s.length) {
        return /* :: */[
                $$String.sub(s, i, j - i | 0),
                res
              ];
      } else {
        var match = Caml_string.get(s, j);
        var switcher = match - 9 | 0;
        if (switcher > 4 || switcher < 0) {
          if (switcher !== 23) {
            _j = j + 1 | 0;
            continue ;
          }
          
        } else if (switcher === 3 || switcher === 2) {
          _j = j + 1 | 0;
          continue ;
        }
        return split1(/* :: */[
                    $$String.sub(s, i, j - i | 0),
                    res
                  ], j + 1 | 0);
      }
    };
  };
  return split1(/* [] */0, 0);
}

function get_ref(r) {
  var v = r[0];
  r[0] = /* [] */0;
  return v;
}

function fst3(param) {
  return param[0];
}

function snd3(param) {
  return param[1];
}

function thd3(param) {
  return param[2];
}

function fst4(param) {
  return param[0];
}

function snd4(param) {
  return param[1];
}

function thd4(param) {
  return param[2];
}

function for4(param) {
  return param[3];
}

function create(str_size) {
  var tbl_size = Caml_int32.div(str_size, Sys.max_string_length) + 1 | 0;
  var tbl = Caml_array.caml_make_vect(tbl_size, Bytes.empty);
  for(var i = 0 ,i_finish = tbl_size - 2 | 0; i <= i_finish; ++i){
    Caml_array.caml_array_set(tbl, i, Caml_bytes.caml_create_bytes(Sys.max_string_length));
  }
  Caml_array.caml_array_set(tbl, tbl_size - 1 | 0, Caml_bytes.caml_create_bytes(Caml_int32.mod_(str_size, Sys.max_string_length)));
  return tbl;
}

function length(tbl) {
  var tbl_size = tbl.length;
  return Caml_int32.imul(Sys.max_string_length, tbl_size - 1 | 0) + Caml_array.caml_array_get(tbl, tbl_size - 1 | 0).length | 0;
}

function get(tbl, ind) {
  return Caml_bytes.get(Caml_array.caml_array_get(tbl, Caml_int32.div(ind, Sys.max_string_length)), Caml_int32.mod_(ind, Sys.max_string_length));
}

function set(tbl, ind, c) {
  Caml_array.caml_array_get(tbl, Caml_int32.div(ind, Sys.max_string_length))[Caml_int32.mod_(ind, Sys.max_string_length)] = c;
  return /* () */0;
}

function blit(src, srcoff, dst, dstoff, len) {
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    set(dst, dstoff + i | 0, get(src, srcoff + i | 0));
  }
  return /* () */0;
}

function output(oc, tbl, pos, len) {
  for(var i = pos ,i_finish = (pos + len | 0) - 1 | 0; i <= i_finish; ++i){
    Pervasives.output_char(oc, get(tbl, i));
  }
  return /* () */0;
}

function unsafe_blit_to_bytes(src, srcoff, dst, dstoff, len) {
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    dst[dstoff + i | 0] = get(src, srcoff + i | 0);
  }
  return /* () */0;
}

function input_bytes(ic, len) {
  var tbl = create(len);
  $$Array.iter((function (str) {
          return Pervasives.really_input(ic, str, 0, str.length);
        }), tbl);
  return tbl;
}

var LongString = {
  create: create,
  length: length,
  get: get,
  set: set,
  blit: blit,
  output: output,
  unsafe_blit_to_bytes: unsafe_blit_to_bytes,
  input_bytes: input_bytes
};

function edit_distance(a, b, cutoff) {
  var la = a.length;
  var lb = b.length;
  var cutoff$1 = Caml_primitive.caml_int_min(la > lb ? la : lb, cutoff);
  if (Pervasives.abs(la - lb | 0) > cutoff$1) {
    return ;
  } else {
    var m = $$Array.make_matrix(la + 1 | 0, lb + 1 | 0, cutoff$1 + 1 | 0);
    Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), 0, 0);
    for(var i = 1; i <= la; ++i){
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, i), 0, i);
    }
    for(var j = 1; j <= lb; ++j){
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), j, j);
    }
    for(var i$1 = 1; i$1 <= la; ++i$1){
      for(var j$1 = Caml_primitive.caml_int_max(1, (i$1 - cutoff$1 | 0) - 1 | 0) ,j_finish = Caml_primitive.caml_int_min(lb, (i$1 + cutoff$1 | 0) + 1 | 0); j$1 <= j_finish; ++j$1){
        var cost = Caml_string.get(a, i$1 - 1 | 0) === Caml_string.get(b, j$1 - 1 | 0) ? 0 : 1;
        var best = Caml_primitive.caml_int_min(1 + Caml_primitive.caml_int_min(Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 1 | 0), j$1), Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1), j$1 - 1 | 0)) | 0, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 1 | 0), j$1 - 1 | 0) + cost | 0);
        var best$1 = i$1 > 1 && j$1 > 1 && Caml_string.get(a, i$1 - 1 | 0) === Caml_string.get(b, j$1 - 2 | 0) && Caml_string.get(a, i$1 - 2 | 0) === Caml_string.get(b, j$1 - 1 | 0) ? Caml_primitive.caml_int_min(best, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 2 | 0), j$1 - 2 | 0) + cost | 0) : best;
        Caml_array.caml_array_set(Caml_array.caml_array_get(m, i$1), j$1, best$1);
      }
    }
    var result = Caml_array.caml_array_get(Caml_array.caml_array_get(m, la), lb);
    if (result > cutoff$1) {
      return ;
    } else {
      return result;
    }
  }
}

function spellcheck(env, name) {
  var match = name.length;
  var switcher = match - 1 | 0;
  var cutoff = switcher > 3 || switcher < 0 ? (
      switcher === 5 || switcher === 4 ? 2 : 3
    ) : (
      switcher >= 2 ? 1 : 0
    );
  return List.fold_left((function (param, param$1) {
                  var target = name;
                  var acc = param;
                  var head = param$1;
                  var match = edit_distance(target, head, cutoff);
                  if (match !== undefined) {
                    var best_dist = acc[1];
                    var dist = match;
                    if (dist < best_dist) {
                      return /* tuple */[
                              /* :: */[
                                head,
                                /* [] */0
                              ],
                              dist
                            ];
                    } else if (dist === best_dist) {
                      return /* tuple */[
                              /* :: */[
                                head,
                                acc[0]
                              ],
                              dist
                            ];
                    } else {
                      return acc;
                    }
                  } else {
                    return acc;
                  }
                }), /* tuple */[
                /* [] */0,
                Pervasives.max_int
              ], env)[0];
}

function did_you_mean(ppf, get_choices) {
  Format.fprintf(ppf, /* Format */[
        /* Formatting_lit */Block.__(17, [
            /* FFlush */2,
            /* End_of_format */0
          ]),
        "@?"
      ]);
  var choices = Curry._1(get_choices, /* () */0);
  if (choices) {
    var match = split_last(choices);
    var rest = match[0];
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_lit */Block.__(17, [
                        /* Force_newline */3,
                        /* String_literal */Block.__(11, [
                            "Hint: Did you mean ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Char_literal */Block.__(12, [
                                            /* "?" */63,
                                            /* Formatting_lit */Block.__(17, [
                                                /* FFlush */2,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "@\nHint: Did you mean %s%s%s?@?"
                  ]), $$String.concat(", ", rest), rest === /* [] */0 ? "" : " or ", match[1]);
  } else {
    return /* () */0;
  }
}

function cut_at(s, c) {
  var pos = $$String.index(s, c);
  return /* tuple */[
          $$String.sub(s, 0, pos),
          $$String.sub(s, pos + 1 | 0, (s.length - pos | 0) - 1 | 0)
        ];
}

var compare$1 = Caml_obj.caml_compare;

var StringSet = $$Set.Make({
      compare: compare$1
    });

var compare$2 = Caml_obj.caml_compare;

var StringMap = $$Map.Make({
      compare: compare$2
    });

function ansi_of_color(param) {
  switch (param) {
    case /* Black */0 :
        return "0";
    case /* Red */1 :
        return "1";
    case /* Green */2 :
        return "2";
    case /* Yellow */3 :
        return "3";
    case /* Blue */4 :
        return "4";
    case /* Magenta */5 :
        return "5";
    case /* Cyan */6 :
        return "6";
    case /* White */7 :
        return "7";
    
  }
}

function code_of_style(param) {
  if (typeof param === "number") {
    switch (param) {
      case /* Bold */0 :
          return "1";
      case /* Reset */1 :
          return "0";
      case /* Dim */2 :
          return "2";
      
    }
  } else if (param.tag) {
    return "4" + ansi_of_color(param[0]);
  } else {
    return "3" + ansi_of_color(param[0]);
  }
}

function ansi_of_style_l(l) {
  var s = l ? (
      l[1] ? $$String.concat(";", List.map(code_of_style, l)) : code_of_style(l[0])
    ) : "0";
  return "\x1b[" + (s + "m");
}

var default_styles = /* record */[
  /* error : :: */[
    /* Bold */0,
    /* :: */[
      /* FG */Block.__(0, [/* Red */1]),
      /* [] */0
    ]
  ],
  /* warning : :: */[
    /* Bold */0,
    /* :: */[
      /* FG */Block.__(0, [/* Magenta */5]),
      /* [] */0
    ]
  ],
  /* loc : :: */[
    /* Bold */0,
    /* [] */0
  ]
];

var cur_styles = /* record */[/* contents */default_styles];

function get_styles(param) {
  return cur_styles[0];
}

function set_styles(s) {
  cur_styles[0] = s;
  return /* () */0;
}

function style_of_tag(s) {
  switch (s) {
    case "dim" :
        return /* :: */[
                /* Dim */2,
                /* [] */0
              ];
    case "error" :
        return cur_styles[0][/* error */0];
    case "filename" :
        return /* :: */[
                /* FG */Block.__(0, [/* Cyan */6]),
                /* [] */0
              ];
    case "info" :
        return /* :: */[
                /* Bold */0,
                /* :: */[
                  /* FG */Block.__(0, [/* Yellow */3]),
                  /* [] */0
                ]
              ];
    case "loc" :
        return cur_styles[0][/* loc */2];
    case "warning" :
        return cur_styles[0][/* warning */1];
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

var color_enabled = /* record */[/* contents */true];

function set_color_tag_handling(ppf) {
  var functions = Format.pp_get_formatter_tag_functions(ppf, /* () */0);
  var partial_arg = functions[/* mark_open_tag */0];
  var partial_arg$1 = functions[/* mark_close_tag */1];
  var functions$prime_000 = function (param) {
    var or_else = partial_arg;
    var s = param;
    try {
      var style = style_of_tag(s);
      if (color_enabled[0]) {
        return ansi_of_style_l(style);
      } else {
        return "";
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Curry._1(or_else, s);
      } else {
        throw exn;
      }
    }
  };
  var functions$prime_001 = function (param) {
    var or_else = partial_arg$1;
    var s = param;
    try {
      style_of_tag(s);
      if (color_enabled[0]) {
        return ansi_of_style_l(/* :: */[
                    /* Reset */1,
                    /* [] */0
                  ]);
      } else {
        return "";
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Curry._1(or_else, s);
      } else {
        throw exn;
      }
    }
  };
  var functions$prime_002 = /* print_open_tag */functions[/* print_open_tag */2];
  var functions$prime_003 = /* print_close_tag */functions[/* print_close_tag */3];
  var functions$prime = /* record */[
    functions$prime_000,
    functions$prime_001,
    functions$prime_002,
    functions$prime_003
  ];
  Format.pp_set_mark_tags(ppf, true);
  Format.pp_set_formatter_tag_functions(ppf, functions$prime);
  Format.pp_set_margin(ppf, Format.pp_get_margin(Format.std_formatter, /* () */0));
  return /* () */0;
}

function should_enable_color(param) {
  var term;
  try {
    term = Caml_sys.caml_sys_getenv("TERM");
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      term = "";
    } else {
      throw exn;
    }
  }
  if (term !== "dumb" && term !== "") {
    return Caml_external_polyfill.resolve("caml_sys_isatty")(Pervasives.stderr);
  } else {
    return false;
  }
}

var first = /* record */[/* contents */true];

var formatter_l_001 = /* :: */[
  Format.err_formatter,
  /* :: */[
    Format.str_formatter,
    /* [] */0
  ]
];

var formatter_l = /* :: */[
  Format.std_formatter,
  formatter_l_001
];

function setup(o) {
  if (first[0]) {
    first[0] = false;
    Format.set_mark_tags(true);
    List.iter(set_color_tag_handling, formatter_l);
    var tmp;
    if (o !== undefined) {
      switch (o) {
        case /* Auto */0 :
            tmp = should_enable_color(/* () */0);
            break;
        case /* Always */1 :
            tmp = true;
            break;
        case /* Never */2 :
            tmp = false;
            break;
        
      }
    } else {
      tmp = should_enable_color(/* () */0);
    }
    color_enabled[0] = tmp;
  }
  return /* () */0;
}

function normalise_eol(s) {
  var b = $$Buffer.create(80);
  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
    if (Caml_string.get(s, i) !== /* "\r" */13) {
      $$Buffer.add_char(b, Caml_string.get(s, i));
    }
    
  }
  return $$Buffer.contents(b);
}

function delete_eol_spaces(src) {
  var len_src = src.length;
  var dst = Caml_bytes.caml_create_bytes(len_src);
  var loop = function (_i_src, _i_dst) {
    while(true) {
      var i_dst = _i_dst;
      var i_src = _i_src;
      if (i_src === len_src) {
        return i_dst;
      } else {
        var c = Caml_string.get(src, i_src);
        if (c !== 9 && c !== 32) {
          dst[i_dst] = c;
          _i_dst = i_dst + 1 | 0;
          _i_src = i_src + 1 | 0;
          continue ;
        } else {
          var _spaces = 1;
          var _i_src$1 = i_src + 1 | 0;
          var i_dst$1 = i_dst;
          while(true) {
            var i_src$1 = _i_src$1;
            var spaces = _spaces;
            if (i_src$1 === len_src) {
              return i_dst$1;
            } else {
              var match = Caml_string.get(src, i_src$1);
              var switcher = match - 9 | 0;
              if (switcher === 0 || switcher === 1) {
                if (switcher !== 0) {
                  dst[i_dst$1] = /* "\n" */10;
                  return loop(i_src$1 + 1 | 0, i_dst$1 + 1 | 0);
                }
                
              } else if (switcher !== 23) {
                for(var n = 0; n <= spaces; ++n){
                  dst[i_dst$1 + n | 0] = Caml_string.get(src, (i_src$1 - spaces | 0) + n | 0);
                }
                return loop(i_src$1 + 1 | 0, (i_dst$1 + spaces | 0) + 1 | 0);
              }
              _i_src$1 = i_src$1 + 1 | 0;
              _spaces = spaces + 1 | 0;
              continue ;
            }
          };
        }
      }
    };
  };
  var stop = loop(0, 0);
  return Bytes.sub_string(dst, 0, stop);
}

var HookExnWrapper = Caml_exceptions.create("Misc.HookExnWrapper");

var HookExn = Caml_exceptions.create("Misc.HookExn");

function raise_direct_hook_exn(e) {
  throw [
        HookExn,
        e
      ];
}

function MakeHooks(M) {
  var hooks = /* record */[/* contents : [] */0];
  var add_hook = function (name, f) {
    hooks[0] = /* :: */[
      /* tuple */[
        name,
        f
      ],
      hooks[0]
    ];
    return /* () */0;
  };
  var apply_hooks = function (sourcefile, intf) {
    var list = hooks[0];
    var hook_info = sourcefile;
    var ast = intf;
    return List.fold_left((function (ast, param) {
                  try {
                    return Curry._2(param[1], hook_info, ast);
                  }
                  catch (raw_error){
                    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
                    if (error[0] === HookExn) {
                      throw error[1];
                    }
                    throw [
                          HookExnWrapper,
                          /* error */error,
                          /* hook_name */param[0],
                          /* hook_info */hook_info
                        ];
                  }
                }), ast, List.sort(Caml_obj.caml_compare, list));
  };
  return {
          add_hook: add_hook,
          apply_hooks: apply_hooks
        };
}

var may = iter;

var may_map = map;

var Stdlib_List = {
  compare: compare,
  equal: equal,
  filter_map: filter_map,
  some_if_all_elements_are_some: some_if_all_elements_are_some,
  map2_prefix: map2_prefix,
  split_at: split_at
};

var Stdlib = {
  List: Stdlib_List,
  $$Option: $$Option,
  $$Array: $$Array$1
};

var Int_literal_converter = {
  $$int: $$int,
  int32: int32,
  int64: int64,
  nativeint: nativeint
};

var Color = {
  ansi_of_style_l: ansi_of_style_l,
  default_styles: default_styles,
  get_styles: get_styles,
  set_styles: set_styles,
  setup: setup,
  set_color_tag_handling: set_color_tag_handling
};

export {
  array_of_list_rev ,
  fatal_error ,
  fatal_errorf ,
  Fatal_error ,
  try_finally ,
  map_end ,
  map_left_right ,
  for_all2 ,
  replicate_list ,
  list_remove ,
  split_last ,
  may ,
  may_map ,
  protect_refs ,
  Stdlib ,
  find_in_path ,
  find_in_path_rel ,
  find_in_path_uncap ,
  remove_file ,
  expand_directory ,
  create_hashtable ,
  copy_file ,
  copy_file_chunk ,
  string_of_file ,
  output_to_bin_file_directly ,
  output_to_file_via_temporary ,
  log2 ,
  align ,
  no_overflow_add ,
  no_overflow_sub ,
  no_overflow_mul ,
  no_overflow_lsl ,
  Int_literal_converter ,
  chop_extensions ,
  search_substring ,
  replace_substring ,
  rev_split_words ,
  get_ref ,
  fst3 ,
  snd3 ,
  thd3 ,
  fst4 ,
  snd4 ,
  thd4 ,
  for4 ,
  LongString ,
  edit_distance ,
  spellcheck ,
  did_you_mean ,
  cut_at ,
  StringSet ,
  StringMap ,
  Color ,
  normalise_eol ,
  delete_eol_spaces ,
  HookExnWrapper ,
  raise_direct_hook_exn ,
  MakeHooks ,
  
}
/* StringSet Not a pure module */
