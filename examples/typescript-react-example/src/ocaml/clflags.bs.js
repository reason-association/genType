// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Arg from "bs-platform/lib/es6/arg.js";
import * as Sys from "bs-platform/lib/es6/sys.js";
import * as List from "bs-platform/lib/es6/list.js";
import * as Misc from "./misc.bs.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Config from "./config.bs.js";
import * as Printf from "bs-platform/lib/es6/printf.js";
import * as Numbers from "./numbers.bs.js";
import * as Caml_sys from "bs-platform/lib/es6/caml_sys.js";
import * as Filename from "bs-platform/lib/es6/filename.js";
import * as Arg_helper from "./arg_helper.bs.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_format from "bs-platform/lib/es6/caml_format.js";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";

var $$Map = Numbers.Int.$$Map;

var of_string = Caml_format.caml_int_of_string;

var of_string$1 = Caml_format.caml_int_of_string;

var Int_arg_helper = Arg_helper.Make({
      Key: {
        of_string: of_string,
        $$Map: {
          empty: $$Map.empty,
          is_empty: $$Map.is_empty,
          mem: $$Map.mem,
          add: $$Map.add,
          update: $$Map.update,
          singleton: $$Map.singleton,
          remove: $$Map.remove,
          merge: $$Map.merge,
          union: $$Map.union,
          compare: $$Map.compare,
          equal: $$Map.equal,
          iter: $$Map.iter,
          fold: $$Map.fold,
          for_all: $$Map.for_all,
          exists: $$Map.exists,
          filter: $$Map.filter,
          partition: $$Map.partition,
          cardinal: $$Map.cardinal,
          bindings: $$Map.bindings,
          min_binding: $$Map.min_binding,
          min_binding_opt: $$Map.min_binding_opt,
          max_binding: $$Map.max_binding,
          max_binding_opt: $$Map.max_binding_opt,
          choose: $$Map.choose,
          choose_opt: $$Map.choose_opt,
          split: $$Map.split,
          find: $$Map.find,
          find_opt: $$Map.find_opt,
          find_first: $$Map.find_first,
          find_first_opt: $$Map.find_first_opt,
          find_last: $$Map.find_last,
          find_last_opt: $$Map.find_last_opt,
          map: $$Map.map,
          mapi: $$Map.mapi
        }
      },
      Value: {
        of_string: of_string$1
      }
    });

var $$Map$1 = Numbers.Int.$$Map;

var of_string$2 = Caml_format.caml_int_of_string;

var of_string$3 = Caml_format.caml_float_of_string;

var Float_arg_helper = Arg_helper.Make({
      Key: {
        of_string: of_string$2,
        $$Map: {
          empty: $$Map$1.empty,
          is_empty: $$Map$1.is_empty,
          mem: $$Map$1.mem,
          add: $$Map$1.add,
          update: $$Map$1.update,
          singleton: $$Map$1.singleton,
          remove: $$Map$1.remove,
          merge: $$Map$1.merge,
          union: $$Map$1.union,
          compare: $$Map$1.compare,
          equal: $$Map$1.equal,
          iter: $$Map$1.iter,
          fold: $$Map$1.fold,
          for_all: $$Map$1.for_all,
          exists: $$Map$1.exists,
          filter: $$Map$1.filter,
          partition: $$Map$1.partition,
          cardinal: $$Map$1.cardinal,
          bindings: $$Map$1.bindings,
          min_binding: $$Map$1.min_binding,
          min_binding_opt: $$Map$1.min_binding_opt,
          max_binding: $$Map$1.max_binding,
          max_binding_opt: $$Map$1.max_binding_opt,
          choose: $$Map$1.choose,
          choose_opt: $$Map$1.choose_opt,
          split: $$Map$1.split,
          find: $$Map$1.find,
          find_opt: $$Map$1.find_opt,
          find_first: $$Map$1.find_first,
          find_first_opt: $$Map$1.find_first_opt,
          find_last: $$Map$1.find_last,
          find_last_opt: $$Map$1.find_last_opt,
          map: $$Map$1.map,
          mapi: $$Map$1.mapi
        }
      },
      Value: {
        of_string: of_string$3
      }
    });

var objfiles = /* record */[/* contents : [] */0];

var ccobjs = /* record */[/* contents : [] */0];

var dllibs = /* record */[/* contents : [] */0];

var compile_only = /* record */[/* contents */false];

var output_name = /* record */[/* contents */undefined];

var include_dirs = /* record */[/* contents : [] */0];

var no_std_include = /* record */[/* contents */false];

var print_types = /* record */[/* contents */false];

var make_archive = /* record */[/* contents */false];

var debug = /* record */[/* contents */false];

var fast = /* record */[/* contents */false];

var use_linscan = /* record */[/* contents */false];

var link_everything = /* record */[/* contents */false];

var custom_runtime = /* record */[/* contents */false];

var no_check_prims = /* record */[/* contents */false];

var bytecode_compatible_32 = /* record */[/* contents */false];

var output_c_object = /* record */[/* contents */false];

var output_complete_object = /* record */[/* contents */false];

var all_ccopts = /* record */[/* contents : [] */0];

var classic = /* record */[/* contents */false];

var nopervasives = /* record */[/* contents */false];

var preprocessor = /* record */[/* contents */undefined];

var all_ppx = /* record */[/* contents : [] */0];

var annotations = /* record */[/* contents */false];

var binary_annotations = /* record */[/* contents */false];

var use_threads = /* record */[/* contents */false];

var use_vmthreads = /* record */[/* contents */false];

var noassert = /* record */[/* contents */false];

var verbose = /* record */[/* contents */false];

var noversion = /* record */[/* contents */false];

var noprompt = /* record */[/* contents */false];

var nopromptcont = /* record */[/* contents */false];

var init_file = /* record */[/* contents */undefined];

var noinit = /* record */[/* contents */false];

var open_modules = /* record */[/* contents : [] */0];

var use_prims = /* record */[/* contents */""];

var use_runtime = /* record */[/* contents */""];

var principal = /* record */[/* contents */false];

var real_paths = /* record */[/* contents */true];

var recursive_types = /* record */[/* contents */false];

var strict_sequence = /* record */[/* contents */false];

var strict_formats = /* record */[/* contents */false];

var applicative_functors = /* record */[/* contents */true];

var make_runtime = /* record */[/* contents */false];

var gprofile = /* record */[/* contents */false];

var c_compiler = /* record */[/* contents */undefined];

var no_auto_link = /* record */[/* contents */false];

var dllpaths = /* record */[/* contents : [] */0];

var make_package = /* record */[/* contents */false];

var for_package = /* record */[/* contents */undefined];

var error_size = /* record */[/* contents */500];

var float_const_prop = /* record */[/* contents */true];

var transparent_modules = /* record */[/* contents */false];

var dump_source = /* record */[/* contents */false];

var dump_parsetree = /* record */[/* contents */false];

var dump_typedtree = /* record */[/* contents */false];

var dump_rawlambda = /* record */[/* contents */false];

var dump_lambda = /* record */[/* contents */false];

var dump_rawclambda = /* record */[/* contents */false];

var dump_clambda = /* record */[/* contents */false];

var dump_rawflambda = /* record */[/* contents */false];

var dump_flambda = /* record */[/* contents */false];

var dump_flambda_let = /* record */[/* contents */undefined];

var dump_flambda_verbose = /* record */[/* contents */false];

var dump_instr = /* record */[/* contents */false];

var keep_asm_file = /* record */[/* contents */false];

var optimize_for_speed = /* record */[/* contents */true];

var opaque = /* record */[/* contents */false];

var dump_cmm = /* record */[/* contents */false];

var dump_selection = /* record */[/* contents */false];

var dump_cse = /* record */[/* contents */false];

var dump_live = /* record */[/* contents */false];

var dump_avail = /* record */[/* contents */false];

var dump_spill = /* record */[/* contents */false];

var dump_split = /* record */[/* contents */false];

var dump_interf = /* record */[/* contents */false];

var dump_prefer = /* record */[/* contents */false];

var dump_regalloc = /* record */[/* contents */false];

var dump_reload = /* record */[/* contents */false];

var dump_scheduling = /* record */[/* contents */false];

var dump_linear = /* record */[/* contents */false];

var dump_interval = /* record */[/* contents */false];

var keep_startup_file = /* record */[/* contents */false];

var dump_combine = /* record */[/* contents */false];

var profile_columns = /* record */[/* contents : [] */0];

var debug_runavail = /* record */[/* contents */false];

var native_code = /* record */[/* contents */false];

var force_slash = /* record */[/* contents */false];

var clambda_checks = /* record */[/* contents */false];

var flambda_invariant_checks = /* record */[/* contents */true];

var dont_write_files = /* record */[/* contents */false];

function std_include_flag(prefix) {
  if (no_std_include[0]) {
    return "";
  } else {
    return prefix + Curry._1(Filename.quote, Config.standard_library);
  }
}

function std_include_dir(param) {
  if (no_std_include[0]) {
    return /* [] */0;
  } else {
    return /* :: */[
            Config.standard_library,
            /* [] */0
          ];
  }
}

var shared = /* record */[/* contents */false];

var dlcode = /* record */[/* contents */true];

var tmp = Config.architecture === "amd64" ? true : false;

var pic_code = /* record */[/* contents */tmp];

var runtime_variant = /* record */[/* contents */""];

var keep_docs = /* record */[/* contents */false];

var keep_locs = /* record */[/* contents */true];

var unsafe_string = Config.safe_string ? /* record */[/* contents */false] : /* record */[/* contents */!Config.default_safe_string];

var classic_inlining = /* record */[/* contents */false];

var inlining_report = /* record */[/* contents */false];

var afl_instrument = /* record */[/* contents */Config.afl_instrument];

var afl_inst_ratio = /* record */[/* contents */100];

var simplify_rounds = /* record */[/* contents */undefined];

var default_simplify_rounds = /* record */[/* contents */1];

function rounds(param) {
  var match = simplify_rounds[0];
  if (match !== undefined) {
    return match;
  } else {
    return default_simplify_rounds[0];
  }
}

var default_inline_threshold = Config.flambda ? 10 : 10 / 8;

var default_inline_toplevel_threshold = 16 * default_inline_threshold | 0;

var inline_threshold = /* record */[/* contents */Curry._1(Float_arg_helper.$$default, default_inline_threshold)];

var inline_toplevel_threshold = /* record */[/* contents */Curry._1(Int_arg_helper.$$default, default_inline_toplevel_threshold)];

var inline_call_cost = /* record */[/* contents */Curry._1(Int_arg_helper.$$default, 5)];

var inline_alloc_cost = /* record */[/* contents */Curry._1(Int_arg_helper.$$default, 7)];

var inline_prim_cost = /* record */[/* contents */Curry._1(Int_arg_helper.$$default, 3)];

var inline_branch_cost = /* record */[/* contents */Curry._1(Int_arg_helper.$$default, 5)];

var inline_indirect_cost = /* record */[/* contents */Curry._1(Int_arg_helper.$$default, 4)];

var inline_branch_factor = /* record */[/* contents */Curry._1(Float_arg_helper.$$default, 0.1)];

var inline_lifting_benefit = /* record */[/* contents */Curry._1(Int_arg_helper.$$default, 1300)];

var inline_max_unroll = /* record */[/* contents */Curry._1(Int_arg_helper.$$default, 0)];

var inline_max_depth = /* record */[/* contents */Curry._1(Int_arg_helper.$$default, 1)];

var unbox_specialised_args = /* record */[/* contents */true];

var unbox_free_vars_of_closures = /* record */[/* contents */true];

var unbox_closures = /* record */[/* contents */false];

var unbox_closures_factor = /* record */[/* contents */10];

var remove_unused_arguments = /* record */[/* contents */false];

function use_inlining_arguments_set(round, arg) {
  var set_int = function (param, param$1, param$2) {
    var round$1 = round;
    var arg = param;
    var $$default = param$1;
    var value = param$2;
    var value$1 = value !== undefined ? value : $$default;
    if (round$1 !== undefined) {
      arg[0] = Curry._3(Int_arg_helper.add_base_override, round$1, value$1, arg[0]);
      return /* () */0;
    } else {
      arg[0] = Curry._2(Int_arg_helper.set_base_default, value$1, Curry._1(Int_arg_helper.reset_base_overrides, arg[0]));
      return /* () */0;
    }
  };
  var set_float = function (param, param$1, param$2) {
    var round$1 = round;
    var arg = param;
    var $$default = param$1;
    var value = param$2;
    var value$1 = value !== undefined ? value : $$default;
    if (round$1 !== undefined) {
      arg[0] = Curry._3(Float_arg_helper.add_base_override, round$1, value$1, arg[0]);
      return /* () */0;
    } else {
      arg[0] = Curry._2(Float_arg_helper.set_base_default, value$1, Curry._1(Float_arg_helper.reset_base_overrides, arg[0]));
      return /* () */0;
    }
  };
  set_int(inline_call_cost, 5, arg[/* inline_call_cost */0]);
  set_int(inline_alloc_cost, 7, arg[/* inline_alloc_cost */1]);
  set_int(inline_prim_cost, 3, arg[/* inline_prim_cost */2]);
  set_int(inline_branch_cost, 5, arg[/* inline_branch_cost */3]);
  set_int(inline_indirect_cost, 4, arg[/* inline_indirect_cost */4]);
  set_int(inline_lifting_benefit, 1300, arg[/* inline_lifting_benefit */5]);
  set_float(inline_branch_factor, 0.1, arg[/* inline_branch_factor */6]);
  set_int(inline_max_depth, 1, arg[/* inline_max_depth */7]);
  set_int(inline_max_unroll, 0, arg[/* inline_max_unroll */8]);
  set_float(inline_threshold, default_inline_threshold, arg[/* inline_threshold */9]);
  return set_int(inline_toplevel_threshold, default_inline_toplevel_threshold, arg[/* inline_toplevel_threshold */10]);
}

var classic_arguments_009 = /* inline_threshold */10 / 8;

var classic_arguments_010 = /* inline_toplevel_threshold */1;

var classic_arguments = /* record */[
  /* inline_call_cost */undefined,
  /* inline_alloc_cost */undefined,
  /* inline_prim_cost */undefined,
  /* inline_branch_cost */undefined,
  /* inline_indirect_cost */undefined,
  /* inline_lifting_benefit */undefined,
  /* inline_branch_factor */undefined,
  /* inline_max_depth */undefined,
  /* inline_max_unroll */undefined,
  classic_arguments_009,
  classic_arguments_010
];

var o2_arguments_000 = /* inline_call_cost */10;

var o2_arguments_001 = /* inline_alloc_cost */14;

var o2_arguments_002 = /* inline_prim_cost */6;

var o2_arguments_003 = /* inline_branch_cost */10;

var o2_arguments_004 = /* inline_indirect_cost */8;

var o2_arguments_007 = /* inline_max_depth */2;

var o2_arguments_009 = /* inline_threshold */25;

var o2_arguments_010 = /* inline_toplevel_threshold */400;

var o2_arguments = /* record */[
  o2_arguments_000,
  o2_arguments_001,
  o2_arguments_002,
  o2_arguments_003,
  o2_arguments_004,
  /* inline_lifting_benefit */undefined,
  /* inline_branch_factor */undefined,
  o2_arguments_007,
  /* inline_max_unroll */undefined,
  o2_arguments_009,
  o2_arguments_010
];

var o3_arguments_000 = /* inline_call_cost */15;

var o3_arguments_001 = /* inline_alloc_cost */21;

var o3_arguments_002 = /* inline_prim_cost */9;

var o3_arguments_003 = /* inline_branch_cost */15;

var o3_arguments_004 = /* inline_indirect_cost */12;

var o3_arguments_006 = /* inline_branch_factor */0;

var o3_arguments_007 = /* inline_max_depth */3;

var o3_arguments_008 = /* inline_max_unroll */1;

var o3_arguments_009 = /* inline_threshold */50;

var o3_arguments_010 = /* inline_toplevel_threshold */800;

var o3_arguments = /* record */[
  o3_arguments_000,
  o3_arguments_001,
  o3_arguments_002,
  o3_arguments_003,
  o3_arguments_004,
  /* inline_lifting_benefit */undefined,
  o3_arguments_006,
  o3_arguments_007,
  o3_arguments_008,
  o3_arguments_009,
  o3_arguments_010
];

var all_passes = /* record */[/* contents : [] */0];

var dumped_passes_list = /* record */[/* contents : [] */0];

function dumped_pass(s) {
  if (!List.mem(s, all_passes[0])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "clflags.ml",
            348,
            2
          ]
        ];
  }
  return List.mem(s, dumped_passes_list[0]);
}

function set_dumped_pass(s, enabled) {
  if (List.mem(s, all_passes[0])) {
    var passes_without_s = List.filter((function (param) {
              return s !== param;
            }))(dumped_passes_list[0]);
    var dumped_passes = enabled ? /* :: */[
        s,
        passes_without_s
      ] : passes_without_s;
    dumped_passes_list[0] = dumped_passes;
    return /* () */0;
  } else {
    return 0;
  }
}

function parse_color_setting(param) {
  switch (param) {
    case "always" :
        return /* Always */1;
    case "auto" :
        return /* Auto */0;
    case "never" :
        return /* Never */2;
    default:
      return ;
  }
}

var color = /* record */[/* contents */undefined];

var unboxed_types = /* record */[/* contents */false];

var arg_spec = /* record */[/* contents : [] */0];

var arg_names = /* record */[/* contents */Misc.StringMap.empty];

function reset_arguments(param) {
  arg_spec[0] = /* [] */0;
  arg_names[0] = Misc.StringMap.empty;
  return /* () */0;
}

function add_arguments(loc, args) {
  return List.iter((function (arg) {
                var arg_name = arg[0];
                try {
                  var loc2 = Curry._2(Misc.StringMap.find, arg_name, arg_names[0]);
                  Curry._1(Printf.eprintf(/* Format */[
                            /* String_literal */Block.__(11, [
                                "Warning: plugin argument ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        " is already defined:\n",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ]),
                            "Warning: plugin argument %s is already defined:\n"
                          ]), arg_name);
                  Curry._1(Printf.eprintf(/* Format */[
                            /* String_literal */Block.__(11, [
                                "   First definition: ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.__(12, [
                                        /* "\n" */10,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ]),
                            "   First definition: %s\n"
                          ]), loc2);
                  return Curry._1(Printf.eprintf(/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "   New definition: ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Char_literal */Block.__(12, [
                                              /* "\n" */10,
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ]),
                                  "   New definition: %s\n"
                                ]), loc);
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    arg_spec[0] = Pervasives.$at(arg_spec[0], /* :: */[
                          arg,
                          /* [] */0
                        ]);
                    arg_names[0] = Curry._3(Misc.StringMap.add, arg_name, loc, arg_names[0]);
                    return /* () */0;
                  } else {
                    throw exn;
                  }
                }
              }), args);
}

function print_arguments(usage) {
  return Arg.usage(arg_spec[0], usage);
}

function parse_arguments(f, msg) {
  try {
    var argv = /* record */[/* contents */Sys.argv];
    var current = /* record */[/* contents */Arg.current[0]];
    return Arg.parse_and_expand_argv_dynamic(current, argv, arg_spec, f, msg);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Arg.Bad) {
      Curry._1(Printf.eprintf(/* Format */[
                /* String */Block.__(2, [
                    /* No_padding */0,
                    /* End_of_format */0
                  ]),
                "%s"
              ]), exn[1]);
      return Pervasives.exit(2);
    } else if (exn[0] === Arg.Help) {
      Curry._1(Printf.printf(/* Format */[
                /* String */Block.__(2, [
                    /* No_padding */0,
                    /* End_of_format */0
                  ]),
                "%s"
              ]), exn[1]);
      return Pervasives.exit(0);
    } else {
      throw exn;
    }
  }
}

var no_implicit_current_dir = /* record */[/* contents */false];

var assume_no_mli = /* record */[/* contents : Mli_na */0];

var record_event_when_debug = /* record */[/* contents */true];

var bs_vscode;

try {
  Caml_sys.caml_sys_getenv("BS_VSCODE");
  bs_vscode = true;
}
catch (exn){
  bs_vscode = false;
}

var dont_record_crc_unit = /* record */[/* contents */undefined];

var bs_only = /* record */[/* contents */false];

var bs_gentype = /* record */[/* contents */undefined];

var no_assert_false = /* record */[/* contents */false];

var bs_quiet = /* record */[/* contents */false];

var dump_location = /* record */[/* contents */true];

var Int_arg_helper_parse = Int_arg_helper.parse;

var Int_arg_helper_parse_no_error = Int_arg_helper.parse_no_error;

var Int_arg_helper_get = Int_arg_helper.get;

var Int_arg_helper$1 = {
  parse: Int_arg_helper_parse,
  parse_no_error: Int_arg_helper_parse_no_error,
  get: Int_arg_helper_get
};

var Float_arg_helper_parse = Float_arg_helper.parse;

var Float_arg_helper_parse_no_error = Float_arg_helper.parse_no_error;

var Float_arg_helper_get = Float_arg_helper.get;

var Float_arg_helper$1 = {
  parse: Float_arg_helper_parse,
  parse_no_error: Float_arg_helper_parse_no_error,
  get: Float_arg_helper_get
};

var o1_arguments = /* record */[
  /* inline_call_cost */undefined,
  /* inline_alloc_cost */undefined,
  /* inline_prim_cost */undefined,
  /* inline_branch_cost */undefined,
  /* inline_indirect_cost */undefined,
  /* inline_lifting_benefit */undefined,
  /* inline_branch_factor */undefined,
  /* inline_max_depth */undefined,
  /* inline_max_unroll */undefined,
  /* inline_threshold */undefined,
  /* inline_toplevel_threshold */undefined
];

var default_inline_max_unroll = 0;

var default_inline_call_cost = 5;

var default_inline_alloc_cost = 7;

var default_inline_prim_cost = 3;

var default_inline_branch_cost = 5;

var default_inline_indirect_cost = 4;

var default_inline_lifting_benefit = 1300;

var default_inline_branch_factor = 0.1;

var default_unbox_closures_factor = 10;

var default_inline_max_depth = 1;

export {
  Int_arg_helper$1 as Int_arg_helper,
  Float_arg_helper$1 as Float_arg_helper,
  classic_arguments ,
  o1_arguments ,
  o2_arguments ,
  o3_arguments ,
  use_inlining_arguments_set ,
  objfiles ,
  ccobjs ,
  dllibs ,
  compile_only ,
  output_name ,
  include_dirs ,
  no_std_include ,
  print_types ,
  make_archive ,
  debug ,
  fast ,
  use_linscan ,
  link_everything ,
  custom_runtime ,
  no_check_prims ,
  bytecode_compatible_32 ,
  output_c_object ,
  output_complete_object ,
  all_ccopts ,
  classic ,
  nopervasives ,
  open_modules ,
  preprocessor ,
  all_ppx ,
  annotations ,
  binary_annotations ,
  use_threads ,
  use_vmthreads ,
  noassert ,
  verbose ,
  noprompt ,
  nopromptcont ,
  init_file ,
  noinit ,
  noversion ,
  use_prims ,
  use_runtime ,
  principal ,
  real_paths ,
  recursive_types ,
  strict_sequence ,
  strict_formats ,
  applicative_functors ,
  make_runtime ,
  gprofile ,
  c_compiler ,
  no_auto_link ,
  dllpaths ,
  make_package ,
  for_package ,
  error_size ,
  float_const_prop ,
  transparent_modules ,
  dump_source ,
  dump_parsetree ,
  dump_typedtree ,
  dump_rawlambda ,
  dump_lambda ,
  dump_rawclambda ,
  dump_clambda ,
  dump_rawflambda ,
  dump_flambda ,
  dump_flambda_let ,
  dump_instr ,
  keep_asm_file ,
  optimize_for_speed ,
  dump_cmm ,
  dump_selection ,
  dump_cse ,
  dump_live ,
  dump_avail ,
  debug_runavail ,
  dump_spill ,
  dump_split ,
  dump_interf ,
  dump_prefer ,
  dump_regalloc ,
  dump_reload ,
  dump_scheduling ,
  dump_linear ,
  dump_interval ,
  keep_startup_file ,
  dump_combine ,
  native_code ,
  default_inline_threshold ,
  inline_threshold ,
  inlining_report ,
  simplify_rounds ,
  default_simplify_rounds ,
  rounds ,
  default_inline_max_unroll ,
  inline_max_unroll ,
  default_inline_toplevel_threshold ,
  inline_toplevel_threshold ,
  default_inline_call_cost ,
  default_inline_alloc_cost ,
  default_inline_prim_cost ,
  default_inline_branch_cost ,
  default_inline_indirect_cost ,
  default_inline_lifting_benefit ,
  inline_call_cost ,
  inline_alloc_cost ,
  inline_prim_cost ,
  inline_branch_cost ,
  inline_indirect_cost ,
  inline_lifting_benefit ,
  default_inline_branch_factor ,
  inline_branch_factor ,
  dont_write_files ,
  std_include_flag ,
  std_include_dir ,
  shared ,
  dlcode ,
  pic_code ,
  runtime_variant ,
  force_slash ,
  keep_docs ,
  keep_locs ,
  unsafe_string ,
  opaque ,
  profile_columns ,
  flambda_invariant_checks ,
  unbox_closures ,
  unbox_closures_factor ,
  default_unbox_closures_factor ,
  unbox_free_vars_of_closures ,
  unbox_specialised_args ,
  clambda_checks ,
  default_inline_max_depth ,
  inline_max_depth ,
  remove_unused_arguments ,
  dump_flambda_verbose ,
  classic_inlining ,
  afl_instrument ,
  afl_inst_ratio ,
  all_passes ,
  dumped_pass ,
  set_dumped_pass ,
  parse_color_setting ,
  color ,
  unboxed_types ,
  arg_spec ,
  add_arguments ,
  parse_arguments ,
  print_arguments ,
  reset_arguments ,
  no_implicit_current_dir ,
  assume_no_mli ,
  record_event_when_debug ,
  bs_vscode ,
  dont_record_crc_unit ,
  bs_only ,
  bs_gentype ,
  no_assert_false ,
  bs_quiet ,
  dump_location ,
  
}
/* Int_arg_helper Not a pure module */
