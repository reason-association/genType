/* TypeScript file generated by genType. */

// tslint:disable-next-line:no-var-requires
import * as CreateBucklescriptBlock from 'bs-platform/lib/js/block.js';

// tslint:disable-next-line:no-var-requires
import * as TypesBS from './Types.bs';

import {list} from '../../src/shims/ReasonPervasives.shim';

// tslint:disable-next-line:interface-over-type-literal
export type t = number;

// tslint:disable-next-line:max-classes-per-file 
export abstract class TypeWithVarsA<x,y> { protected opaque!: x | y }; /* simulate opaque types */

export const A: <x,y>(_1:x, _2:y) => TypeWithVarsA<x,y> = function _(Arg1, Arg2) { return CreateBucklescriptBlock.__(0 as any, [Arg1, Arg2]) }

// tslint:disable-next-line:max-classes-per-file 
export abstract class TypeWithVarsB<z> { protected opaque!: z }; /* simulate opaque types */

export const B: <z>(_1:z) => TypeWithVarsB<z> = function _(Arg1) { return CreateBucklescriptBlock.__(1 as any, [Arg1]) }

export type typeWithVars<x,y,z> =
  | TypeWithVarsA<x,y>
  | TypeWithVarsB<z>;

// tslint:disable-next-line:interface-over-type-literal
export type tree = {
  readonly label: string, 
  readonly left?: tree, 
  readonly right?: tree
};

// tslint:disable-next-line:interface-over-type-literal
export type selfRecursive = {readonly self: selfRecursive};

// tslint:disable-next-line:interface-over-type-literal
export type mutuallyRecursiveA = {readonly b: mutuallyRecursiveB};

// tslint:disable-next-line:interface-over-type-literal
export type mutuallyRecursiveB = {readonly a: mutuallyRecursiveA};

export const someIntList: list<number> = TypesBS.someIntList;

export const map: <T1,T2>(_1:((_1:T1) => T2), _2:list<T1>) => list<T2> = TypesBS.map;

export const swap: (_1:tree) => tree = TypesBS.swap;

export const selfRecursiveConverter: (_1:selfRecursive) => selfRecursive = function _(Arg1) { const result = 
/* WARNING: circular type selfRecursive. Only shallow converter applied. */
  TypesBS.selfRecursiveConverter([Arg1.self]); return {self:result[0]} };

export const mutuallyRecursiveConverter: (_1:mutuallyRecursiveA) => mutuallyRecursiveB = function _(Arg1) { const result = 
/* WARNING: circular type mutuallyRecursiveB. Only shallow converter applied. */
  TypesBS.mutuallyRecursiveConverter([[Arg1.b.a]]); return {a:{b:result[0][0]}} };

export const testFunctionOnOptionsAsArgument: <T1,a>(_1:(null | undefined | a), _2:((_1:(null | undefined | a)) => T1)) => T1 = function _(Arg1, Arg2) { const result = TypesBS.testFunctionOnOptionsAsArgument((Arg1 == null ? undefined : Arg1), Arg2); return result };
