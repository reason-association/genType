// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Int32 from "bs-platform/lib/es6/int32.js";
import * as Int64 from "bs-platform/lib/es6/int64.js";
import * as $$Location from "./location.bs.js";
import * as Nativeint from "bs-platform/lib/es6/nativeint.js";
import * as Syntaxerr from "./syntaxerr.bs.js";
import * as Docstrings from "./docstrings.bs.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";

var default_loc = {
  contents: $$Location.none
};

function with_default_loc(l, f) {
  var old = default_loc.contents;
  default_loc.contents = l;
  try {
    var r = Curry._1(f, /* () */0);
    default_loc.contents = old;
    return r;
  }
  catch (exn){
    default_loc.contents = old;
    throw exn;
  }
}

function integer(suffix, i) {
  return /* Pconst_integer */Block.__(0, [
            i,
            suffix
          ]);
}

function $$int(suffix, i) {
  return /* Pconst_integer */Block.__(0, [
            String(i),
            suffix
          ]);
}

function int32($staropt$star, i) {
  var suffix = $staropt$star !== undefined ? $staropt$star : /* "l" */108;
  return /* Pconst_integer */Block.__(0, [
            Int32.to_string(i),
            suffix
          ]);
}

function int64($staropt$star, i) {
  var suffix = $staropt$star !== undefined ? $staropt$star : /* "L" */76;
  return /* Pconst_integer */Block.__(0, [
            Int64.to_string(i),
            suffix
          ]);
}

function nativeint($staropt$star, i) {
  var suffix = $staropt$star !== undefined ? $staropt$star : /* "n" */110;
  return /* Pconst_integer */Block.__(0, [
            Nativeint.to_string(i),
            suffix
          ]);
}

function $$float(suffix, f) {
  return /* Pconst_float */Block.__(3, [
            f,
            suffix
          ]);
}

function $$char(c) {
  return /* Pconst_char */Block.__(1, [c]);
}

function string(quotation_delimiter, s) {
  return /* Pconst_string */Block.__(2, [
            s,
            quotation_delimiter
          ]);
}

function mk($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  return {
          ptyp_desc: d,
          ptyp_loc: loc,
          ptyp_attributes: attrs
        };
}

function attr(d, a) {
  return {
          ptyp_desc: d.ptyp_desc,
          ptyp_loc: d.ptyp_loc,
          ptyp_attributes: Pervasives.$at(d.ptyp_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function any(loc, attrs, param) {
  return mk(loc, attrs, /* Ptyp_any */0);
}

function $$var(loc, attrs, a) {
  return mk(loc, attrs, /* Ptyp_var */Block.__(0, [a]));
}

function arrow(loc, attrs, a, b, c) {
  return mk(loc, attrs, /* Ptyp_arrow */Block.__(1, [
                a,
                b,
                c
              ]));
}

function tuple(loc, attrs, a) {
  return mk(loc, attrs, /* Ptyp_tuple */Block.__(2, [a]));
}

function constr(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_constr */Block.__(3, [
                a,
                b
              ]));
}

function object_(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_object */Block.__(4, [
                a,
                b
              ]));
}

function class_(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_class */Block.__(5, [
                a,
                b
              ]));
}

function alias(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_alias */Block.__(6, [
                a,
                b
              ]));
}

function variant(loc, attrs, a, b, c) {
  return mk(loc, attrs, /* Ptyp_variant */Block.__(7, [
                a,
                b,
                c
              ]));
}

function poly(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_poly */Block.__(8, [
                a,
                b
              ]));
}

function $$package(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_package */Block.__(9, [/* tuple */[
                  a,
                  b
                ]]));
}

function extension(loc, attrs, a) {
  return mk(loc, attrs, /* Ptyp_extension */Block.__(10, [a]));
}

function force_poly(t) {
  var match = t.ptyp_desc;
  if (typeof match !== "number" && match.tag === /* Ptyp_poly */8) {
    return t;
  }
  return poly(t.ptyp_loc, undefined, /* [] */0, t);
}

function varify_constructors(var_names, t) {
  var check_variable = function (vl, loc, v) {
    if (List.mem(v, vl)) {
      throw [
            Syntaxerr.$$Error,
            /* Variable_in_scope */Block.__(4, [
                loc,
                v
              ])
          ];
    } else {
      return 0;
    }
  };
  var var_names$1 = List.map((function (v) {
          return v.txt;
        }), var_names);
  var loop = function (t) {
    var match = t.ptyp_desc;
    var desc;
    if (typeof match === "number") {
      desc = /* Ptyp_any */0;
    } else {
      switch (match.tag | 0) {
        case /* Ptyp_var */0 :
            var x = match[0];
            check_variable(var_names$1, t.ptyp_loc, x);
            desc = /* Ptyp_var */Block.__(0, [x]);
            break;
        case /* Ptyp_arrow */1 :
            desc = /* Ptyp_arrow */Block.__(1, [
                match[0],
                loop(match[1]),
                loop(match[2])
              ]);
            break;
        case /* Ptyp_tuple */2 :
            desc = /* Ptyp_tuple */Block.__(2, [List.map(loop, match[0])]);
            break;
        case /* Ptyp_constr */3 :
            var longident = match[0];
            var match$1 = longident.txt;
            var exit = 0;
            switch (match$1.tag | 0) {
              case /* Lident */0 :
                  if (match[1]) {
                    exit = 1;
                  } else {
                    var s = match$1[0];
                    if (List.mem(s, var_names$1)) {
                      desc = /* Ptyp_var */Block.__(0, [s]);
                    } else {
                      exit = 1;
                    }
                  }
                  break;
              case /* Ldot */1 :
              case /* Lapply */2 :
                  exit = 1;
                  break;
              
            }
            if (exit === 1) {
              desc = /* Ptyp_constr */Block.__(3, [
                  longident,
                  List.map(loop, match[1])
                ]);
            }
            break;
        case /* Ptyp_object */4 :
            desc = /* Ptyp_object */Block.__(4, [
                List.map(loop_object_field, match[0]),
                match[1]
              ]);
            break;
        case /* Ptyp_class */5 :
            desc = /* Ptyp_class */Block.__(5, [
                match[0],
                List.map(loop, match[1])
              ]);
            break;
        case /* Ptyp_alias */6 :
            var string = match[1];
            check_variable(var_names$1, t.ptyp_loc, string);
            desc = /* Ptyp_alias */Block.__(6, [
                loop(match[0]),
                string
              ]);
            break;
        case /* Ptyp_variant */7 :
            desc = /* Ptyp_variant */Block.__(7, [
                List.map(loop_row_field, match[0]),
                match[1],
                match[2]
              ]);
            break;
        case /* Ptyp_poly */8 :
            var string_lst = match[0];
            List.iter((function (v) {
                    return check_variable(var_names$1, t.ptyp_loc, v.txt);
                  }), string_lst);
            desc = /* Ptyp_poly */Block.__(8, [
                string_lst,
                loop(match[1])
              ]);
            break;
        case /* Ptyp_package */9 :
            var match$2 = match[0];
            desc = /* Ptyp_package */Block.__(9, [/* tuple */[
                  match$2[0],
                  List.map((function (param) {
                          return /* tuple */[
                                  param[0],
                                  loop(param[1])
                                ];
                        }), match$2[1])
                ]]);
            break;
        case /* Ptyp_extension */10 :
            var match$3 = match[0];
            desc = /* Ptyp_extension */Block.__(10, [/* tuple */[
                  match$3[0],
                  match$3[1]
                ]]);
            break;
        
      }
    }
    return {
            ptyp_desc: desc,
            ptyp_loc: t.ptyp_loc,
            ptyp_attributes: t.ptyp_attributes
          };
  };
  var loop_row_field = function (param) {
    if (param.tag) {
      return /* Rinherit */Block.__(1, [loop(param[0])]);
    } else {
      return /* Rtag */Block.__(0, [
                param[0],
                param[1],
                param[2],
                List.map(loop, param[3])
              ]);
    }
  };
  var loop_object_field = function (param) {
    if (param.tag) {
      return /* Oinherit */Block.__(1, [loop(param[0])]);
    } else {
      return /* Otag */Block.__(0, [
                param[0],
                param[1],
                loop(param[2])
              ]);
    }
  };
  return loop(t);
}

var Typ = {
  mk: mk,
  attr: attr,
  any: any,
  $$var: $$var,
  arrow: arrow,
  tuple: tuple,
  constr: constr,
  object_: object_,
  class_: class_,
  alias: alias,
  variant: variant,
  poly: poly,
  $$package: $$package,
  extension: extension,
  force_poly: force_poly,
  varify_constructors: varify_constructors
};

function mk$1($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  return {
          ppat_desc: d,
          ppat_loc: loc,
          ppat_attributes: attrs
        };
}

function attr$1(d, a) {
  return {
          ppat_desc: d.ppat_desc,
          ppat_loc: d.ppat_loc,
          ppat_attributes: Pervasives.$at(d.ppat_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function any$1(loc, attrs, param) {
  return mk$1(loc, attrs, /* Ppat_any */0);
}

function $$var$1(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_var */Block.__(0, [a]));
}

function alias$1(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_alias */Block.__(1, [
                a,
                b
              ]));
}

function constant(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_constant */Block.__(2, [a]));
}

function interval(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_interval */Block.__(3, [
                a,
                b
              ]));
}

function tuple$1(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_tuple */Block.__(4, [a]));
}

function construct(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_construct */Block.__(5, [
                a,
                b
              ]));
}

function variant$1(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_variant */Block.__(6, [
                a,
                b
              ]));
}

function record(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_record */Block.__(7, [
                a,
                b
              ]));
}

function array(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_array */Block.__(8, [a]));
}

function or_(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_or */Block.__(9, [
                a,
                b
              ]));
}

function constraint_(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_constraint */Block.__(10, [
                a,
                b
              ]));
}

function type_(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_type */Block.__(11, [a]));
}

function lazy_(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_lazy */Block.__(12, [a]));
}

function unpack(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_unpack */Block.__(13, [a]));
}

function open_(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_open */Block.__(16, [
                a,
                b
              ]));
}

function exception_(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_exception */Block.__(14, [a]));
}

function extension$1(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_extension */Block.__(15, [a]));
}

var Pat = {
  mk: mk$1,
  attr: attr$1,
  any: any$1,
  $$var: $$var$1,
  alias: alias$1,
  constant: constant,
  interval: interval,
  tuple: tuple$1,
  construct: construct,
  variant: variant$1,
  record: record,
  array: array,
  or_: or_,
  constraint_: constraint_,
  type_: type_,
  lazy_: lazy_,
  unpack: unpack,
  open_: open_,
  exception_: exception_,
  extension: extension$1
};

function mk$2($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  return {
          pexp_desc: d,
          pexp_loc: loc,
          pexp_attributes: attrs
        };
}

function attr$2(d, a) {
  return {
          pexp_desc: d.pexp_desc,
          pexp_loc: d.pexp_loc,
          pexp_attributes: Pervasives.$at(d.pexp_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function ident(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_ident */Block.__(0, [a]));
}

function constant$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_constant */Block.__(1, [a]));
}

function let_(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_let */Block.__(2, [
                a,
                b,
                c
              ]));
}

function fun_(loc, attrs, a, b, c, d) {
  return mk$2(loc, attrs, /* Pexp_fun */Block.__(4, [
                a,
                b,
                c,
                d
              ]));
}

function function_(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_function */Block.__(3, [a]));
}

function apply(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_apply */Block.__(5, [
                a,
                b
              ]));
}

function match_(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_match */Block.__(6, [
                a,
                b
              ]));
}

function try_(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_try */Block.__(7, [
                a,
                b
              ]));
}

function tuple$2(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_tuple */Block.__(8, [a]));
}

function construct$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_construct */Block.__(9, [
                a,
                b
              ]));
}

function variant$2(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_variant */Block.__(10, [
                a,
                b
              ]));
}

function record$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_record */Block.__(11, [
                a,
                b
              ]));
}

function field(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_field */Block.__(12, [
                a,
                b
              ]));
}

function setfield(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_setfield */Block.__(13, [
                a,
                b,
                c
              ]));
}

function array$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_array */Block.__(14, [a]));
}

function ifthenelse(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_ifthenelse */Block.__(15, [
                a,
                b,
                c
              ]));
}

function sequence(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_sequence */Block.__(16, [
                a,
                b
              ]));
}

function while_(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_while */Block.__(17, [
                a,
                b
              ]));
}

function for_(loc, attrs, a, b, c, d, e) {
  return mk$2(loc, attrs, /* Pexp_for */Block.__(18, [
                a,
                b,
                c,
                d,
                e
              ]));
}

function constraint_$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_constraint */Block.__(19, [
                a,
                b
              ]));
}

function coerce(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_coerce */Block.__(20, [
                a,
                b,
                c
              ]));
}

function send(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_send */Block.__(21, [
                a,
                b
              ]));
}

function new_(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_new */Block.__(22, [a]));
}

function setinstvar(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_setinstvar */Block.__(23, [
                a,
                b
              ]));
}

function override(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_override */Block.__(24, [a]));
}

function letmodule(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_letmodule */Block.__(25, [
                a,
                b,
                c
              ]));
}

function letexception(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_letexception */Block.__(26, [
                a,
                b
              ]));
}

function assert_(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_assert */Block.__(27, [a]));
}

function lazy_$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_lazy */Block.__(28, [a]));
}

function poly$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_poly */Block.__(29, [
                a,
                b
              ]));
}

function object_$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_object */Block.__(30, [a]));
}

function newtype(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_newtype */Block.__(31, [
                a,
                b
              ]));
}

function pack(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_pack */Block.__(32, [a]));
}

function open_$1(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_open */Block.__(33, [
                a,
                b,
                c
              ]));
}

function extension$2(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_extension */Block.__(34, [a]));
}

function unreachable(loc, attrs, param) {
  return mk$2(loc, attrs, /* Pexp_unreachable */0);
}

function $$case(lhs, guard, rhs) {
  return {
          pc_lhs: lhs,
          pc_guard: guard,
          pc_rhs: rhs
        };
}

function mk$3($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  return {
          pmty_desc: d,
          pmty_loc: loc,
          pmty_attributes: attrs
        };
}

function attr$3(d, a) {
  return {
          pmty_desc: d.pmty_desc,
          pmty_loc: d.pmty_loc,
          pmty_attributes: Pervasives.$at(d.pmty_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function ident$1(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_ident */Block.__(0, [a]));
}

function alias$2(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_alias */Block.__(6, [a]));
}

function signature(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_signature */Block.__(1, [a]));
}

function functor_(loc, attrs, a, b, c) {
  return mk$3(loc, attrs, /* Pmty_functor */Block.__(2, [
                a,
                b,
                c
              ]));
}

function with_(loc, attrs, a, b) {
  return mk$3(loc, attrs, /* Pmty_with */Block.__(3, [
                a,
                b
              ]));
}

function typeof_(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_typeof */Block.__(4, [a]));
}

function extension$3(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_extension */Block.__(5, [a]));
}

var Mty = {
  mk: mk$3,
  attr: attr$3,
  ident: ident$1,
  alias: alias$2,
  signature: signature,
  functor_: functor_,
  with_: with_,
  typeof_: typeof_,
  extension: extension$3
};

function mk$4($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  return {
          pmod_desc: d,
          pmod_loc: loc,
          pmod_attributes: attrs
        };
}

function attr$4(d, a) {
  return {
          pmod_desc: d.pmod_desc,
          pmod_loc: d.pmod_loc,
          pmod_attributes: Pervasives.$at(d.pmod_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function ident$2(loc, attrs, x) {
  return mk$4(loc, attrs, /* Pmod_ident */Block.__(0, [x]));
}

function structure(loc, attrs, x) {
  return mk$4(loc, attrs, /* Pmod_structure */Block.__(1, [x]));
}

function functor_$1(loc, attrs, arg, arg_ty, body) {
  return mk$4(loc, attrs, /* Pmod_functor */Block.__(2, [
                arg,
                arg_ty,
                body
              ]));
}

function apply$1(loc, attrs, m1, m2) {
  return mk$4(loc, attrs, /* Pmod_apply */Block.__(3, [
                m1,
                m2
              ]));
}

function constraint_$2(loc, attrs, m, mty) {
  return mk$4(loc, attrs, /* Pmod_constraint */Block.__(4, [
                m,
                mty
              ]));
}

function unpack$1(loc, attrs, e) {
  return mk$4(loc, attrs, /* Pmod_unpack */Block.__(5, [e]));
}

function extension$4(loc, attrs, a) {
  return mk$4(loc, attrs, /* Pmod_extension */Block.__(6, [a]));
}

var Mod = {
  mk: mk$4,
  attr: attr$4,
  ident: ident$2,
  structure: structure,
  functor_: functor_$1,
  apply: apply$1,
  constraint_: constraint_$2,
  unpack: unpack$1,
  extension: extension$4
};

function mk$5($staropt$star, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  return {
          psig_desc: d,
          psig_loc: loc
        };
}

function value(loc, a) {
  return mk$5(loc, /* Psig_value */Block.__(0, [a]));
}

function type_$1(loc, rec_flag, a) {
  return mk$5(loc, /* Psig_type */Block.__(1, [
                rec_flag,
                a
              ]));
}

function type_extension(loc, a) {
  return mk$5(loc, /* Psig_typext */Block.__(2, [a]));
}

function exception_$1(loc, a) {
  return mk$5(loc, /* Psig_exception */Block.__(3, [a]));
}

function module_(loc, a) {
  return mk$5(loc, /* Psig_module */Block.__(4, [a]));
}

function rec_module(loc, a) {
  return mk$5(loc, /* Psig_recmodule */Block.__(5, [a]));
}

function modtype(loc, a) {
  return mk$5(loc, /* Psig_modtype */Block.__(6, [a]));
}

function open_$2(loc, a) {
  return mk$5(loc, /* Psig_open */Block.__(7, [a]));
}

function include_(loc, a) {
  return mk$5(loc, /* Psig_include */Block.__(8, [a]));
}

function class_$1(loc, a) {
  return mk$5(loc, /* Psig_class */Block.__(9, [a]));
}

function class_type(loc, a) {
  return mk$5(loc, /* Psig_class_type */Block.__(10, [a]));
}

function extension$5(loc, $staropt$star, a) {
  var attrs = $staropt$star !== undefined ? $staropt$star : /* [] */0;
  return mk$5(loc, /* Psig_extension */Block.__(12, [
                a,
                attrs
              ]));
}

function attribute(loc, a) {
  return mk$5(loc, /* Psig_attribute */Block.__(11, [a]));
}

function text(txt) {
  var f_txt = List.filter((function (ds) {
            return Docstrings.docstring_body(ds) !== "";
          }))(txt);
  return List.map((function (ds) {
                var a = Docstrings.text_attr(ds);
                var loc = Docstrings.docstring_loc(ds);
                return mk$5(loc, /* Psig_attribute */Block.__(11, [a]));
              }), f_txt);
}

var Sig = {
  mk: mk$5,
  value: value,
  type_: type_$1,
  type_extension: type_extension,
  exception_: exception_$1,
  module_: module_,
  rec_module: rec_module,
  modtype: modtype,
  open_: open_$2,
  include_: include_,
  class_: class_$1,
  class_type: class_type,
  extension: extension$5,
  attribute: attribute,
  text: text
};

function mk$6($staropt$star, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  return {
          pstr_desc: d,
          pstr_loc: loc
        };
}

function $$eval(loc, $staropt$star, a) {
  var attrs = $staropt$star !== undefined ? $staropt$star : /* [] */0;
  return mk$6(loc, /* Pstr_eval */Block.__(0, [
                a,
                attrs
              ]));
}

function value$1(loc, a, b) {
  return mk$6(loc, /* Pstr_value */Block.__(1, [
                a,
                b
              ]));
}

function primitive(loc, a) {
  return mk$6(loc, /* Pstr_primitive */Block.__(2, [a]));
}

function type_$2(loc, rec_flag, a) {
  return mk$6(loc, /* Pstr_type */Block.__(3, [
                rec_flag,
                a
              ]));
}

function type_extension$1(loc, a) {
  return mk$6(loc, /* Pstr_typext */Block.__(4, [a]));
}

function exception_$2(loc, a) {
  return mk$6(loc, /* Pstr_exception */Block.__(5, [a]));
}

function module_$1(loc, a) {
  return mk$6(loc, /* Pstr_module */Block.__(6, [a]));
}

function rec_module$1(loc, a) {
  return mk$6(loc, /* Pstr_recmodule */Block.__(7, [a]));
}

function modtype$1(loc, a) {
  return mk$6(loc, /* Pstr_modtype */Block.__(8, [a]));
}

function open_$3(loc, a) {
  return mk$6(loc, /* Pstr_open */Block.__(9, [a]));
}

function class_$2(loc, a) {
  return mk$6(loc, /* Pstr_class */Block.__(10, [a]));
}

function class_type$1(loc, a) {
  return mk$6(loc, /* Pstr_class_type */Block.__(11, [a]));
}

function include_$1(loc, a) {
  return mk$6(loc, /* Pstr_include */Block.__(12, [a]));
}

function extension$6(loc, $staropt$star, a) {
  var attrs = $staropt$star !== undefined ? $staropt$star : /* [] */0;
  return mk$6(loc, /* Pstr_extension */Block.__(14, [
                a,
                attrs
              ]));
}

function attribute$1(loc, a) {
  return mk$6(loc, /* Pstr_attribute */Block.__(13, [a]));
}

function text$1(txt) {
  var f_txt = List.filter((function (ds) {
            return Docstrings.docstring_body(ds) !== "";
          }))(txt);
  return List.map((function (ds) {
                var a = Docstrings.text_attr(ds);
                var loc = Docstrings.docstring_loc(ds);
                return mk$6(loc, /* Pstr_attribute */Block.__(13, [a]));
              }), f_txt);
}

var Str = {
  mk: mk$6,
  $$eval: $$eval,
  value: value$1,
  primitive: primitive,
  type_: type_$2,
  type_extension: type_extension$1,
  exception_: exception_$2,
  module_: module_$1,
  rec_module: rec_module$1,
  modtype: modtype$1,
  open_: open_$3,
  class_: class_$2,
  class_type: class_type$1,
  include_: include_$1,
  extension: extension$6,
  attribute: attribute$1,
  text: text$1
};

function mk$7($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  return {
          pcl_desc: d,
          pcl_loc: loc,
          pcl_attributes: attrs
        };
}

function attr$5(d, a) {
  return {
          pcl_desc: d.pcl_desc,
          pcl_loc: d.pcl_loc,
          pcl_attributes: Pervasives.$at(d.pcl_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function constr$1(loc, attrs, a, b) {
  return mk$7(loc, attrs, /* Pcl_constr */Block.__(0, [
                a,
                b
              ]));
}

function structure$1(loc, attrs, a) {
  return mk$7(loc, attrs, /* Pcl_structure */Block.__(1, [a]));
}

function fun_$1(loc, attrs, a, b, c, d) {
  return mk$7(loc, attrs, /* Pcl_fun */Block.__(2, [
                a,
                b,
                c,
                d
              ]));
}

function apply$2(loc, attrs, a, b) {
  return mk$7(loc, attrs, /* Pcl_apply */Block.__(3, [
                a,
                b
              ]));
}

function let_$1(loc, attrs, a, b, c) {
  return mk$7(loc, attrs, /* Pcl_let */Block.__(4, [
                a,
                b,
                c
              ]));
}

function constraint_$3(loc, attrs, a, b) {
  return mk$7(loc, attrs, /* Pcl_constraint */Block.__(5, [
                a,
                b
              ]));
}

function extension$7(loc, attrs, a) {
  return mk$7(loc, attrs, /* Pcl_extension */Block.__(6, [a]));
}

function open_$4(loc, attrs, a, b, c) {
  return mk$7(loc, attrs, /* Pcl_open */Block.__(7, [
                a,
                b,
                c
              ]));
}

var Cl = {
  mk: mk$7,
  attr: attr$5,
  constr: constr$1,
  structure: structure$1,
  fun_: fun_$1,
  apply: apply$2,
  let_: let_$1,
  constraint_: constraint_$3,
  extension: extension$7,
  open_: open_$4
};

function mk$8($staropt$star, $staropt$star$1, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  return {
          pcty_desc: d,
          pcty_loc: loc,
          pcty_attributes: attrs
        };
}

function attr$6(d, a) {
  return {
          pcty_desc: d.pcty_desc,
          pcty_loc: d.pcty_loc,
          pcty_attributes: Pervasives.$at(d.pcty_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function constr$2(loc, attrs, a, b) {
  return mk$8(loc, attrs, /* Pcty_constr */Block.__(0, [
                a,
                b
              ]));
}

function signature$1(loc, attrs, a) {
  return mk$8(loc, attrs, /* Pcty_signature */Block.__(1, [a]));
}

function arrow$1(loc, attrs, a, b, c) {
  return mk$8(loc, attrs, /* Pcty_arrow */Block.__(2, [
                a,
                b,
                c
              ]));
}

function extension$8(loc, attrs, a) {
  return mk$8(loc, attrs, /* Pcty_extension */Block.__(3, [a]));
}

function open_$5(loc, attrs, a, b, c) {
  return mk$8(loc, attrs, /* Pcty_open */Block.__(4, [
                a,
                b,
                c
              ]));
}

var Cty = {
  mk: mk$8,
  attr: attr$6,
  constr: constr$2,
  signature: signature$1,
  arrow: arrow$1,
  extension: extension$8,
  open_: open_$5
};

function mk$9($staropt$star, $staropt$star$1, $staropt$star$2, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  return {
          pctf_desc: d,
          pctf_loc: loc,
          pctf_attributes: Docstrings.add_docs_attrs(docs, attrs)
        };
}

function inherit_(loc, attrs, a) {
  return mk$9(loc, attrs, undefined, /* Pctf_inherit */Block.__(0, [a]));
}

function val_(loc, attrs, a, b, c, d) {
  return mk$9(loc, attrs, undefined, /* Pctf_val */Block.__(1, [/* tuple */[
                  a,
                  b,
                  c,
                  d
                ]]));
}

function method_(loc, attrs, a, b, c, d) {
  return mk$9(loc, attrs, undefined, /* Pctf_method */Block.__(2, [/* tuple */[
                  a,
                  b,
                  c,
                  d
                ]]));
}

function constraint_$4(loc, attrs, a, b) {
  return mk$9(loc, attrs, undefined, /* Pctf_constraint */Block.__(3, [/* tuple */[
                  a,
                  b
                ]]));
}

function extension$9(loc, attrs, a) {
  return mk$9(loc, attrs, undefined, /* Pctf_extension */Block.__(5, [a]));
}

function attribute$2(loc, a) {
  return mk$9(loc, undefined, undefined, /* Pctf_attribute */Block.__(4, [a]));
}

function text$2(txt) {
  var f_txt = List.filter((function (ds) {
            return Docstrings.docstring_body(ds) !== "";
          }))(txt);
  return List.map((function (ds) {
                return attribute$2(Docstrings.docstring_loc(ds), Docstrings.text_attr(ds));
              }), f_txt);
}

function attr$7(d, a) {
  return {
          pctf_desc: d.pctf_desc,
          pctf_loc: d.pctf_loc,
          pctf_attributes: Pervasives.$at(d.pctf_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function mk$10($staropt$star, $staropt$star$1, $staropt$star$2, d) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  return {
          pcf_desc: d,
          pcf_loc: loc,
          pcf_attributes: Docstrings.add_docs_attrs(docs, attrs)
        };
}

function inherit_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, undefined, /* Pcf_inherit */Block.__(0, [
                a,
                b,
                c
              ]));
}

function val_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, undefined, /* Pcf_val */Block.__(1, [/* tuple */[
                  a,
                  b,
                  c
                ]]));
}

function method_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, undefined, /* Pcf_method */Block.__(2, [/* tuple */[
                  a,
                  b,
                  c
                ]]));
}

function constraint_$5(loc, attrs, a, b) {
  return mk$10(loc, attrs, undefined, /* Pcf_constraint */Block.__(3, [/* tuple */[
                  a,
                  b
                ]]));
}

function initializer_(loc, attrs, a) {
  return mk$10(loc, attrs, undefined, /* Pcf_initializer */Block.__(4, [a]));
}

function extension$10(loc, attrs, a) {
  return mk$10(loc, attrs, undefined, /* Pcf_extension */Block.__(6, [a]));
}

function attribute$3(loc, a) {
  return mk$10(loc, undefined, undefined, /* Pcf_attribute */Block.__(5, [a]));
}

function text$3(txt) {
  var f_txt = List.filter((function (ds) {
            return Docstrings.docstring_body(ds) !== "";
          }))(txt);
  return List.map((function (ds) {
                return attribute$3(Docstrings.docstring_loc(ds), Docstrings.text_attr(ds));
              }), f_txt);
}

function virtual_(ct) {
  return /* Cfk_virtual */Block.__(0, [ct]);
}

function concrete(o, e) {
  return /* Cfk_concrete */Block.__(1, [
            o,
            e
          ]);
}

function attr$8(d, a) {
  return {
          pcf_desc: d.pcf_desc,
          pcf_loc: d.pcf_loc,
          pcf_attributes: Pervasives.$at(d.pcf_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function mk$11($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, typ) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var prim = $staropt$star$3 !== undefined ? $staropt$star$3 : /* [] */0;
  return {
          pval_name: name,
          pval_type: typ,
          pval_prim: prim,
          pval_attributes: Docstrings.add_docs_attrs(docs, attrs),
          pval_loc: loc
        };
}

var Val = {
  mk: mk$11
};

function mk$12($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, typ) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var text = $staropt$star$3 !== undefined ? $staropt$star$3 : /* [] */0;
  return {
          pmd_name: name,
          pmd_type: typ,
          pmd_attributes: Docstrings.add_text_attrs(text, Docstrings.add_docs_attrs(docs, attrs)),
          pmd_loc: loc
        };
}

var Md = {
  mk: mk$12
};

function mk$13($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, typ, name) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var text = $staropt$star$3 !== undefined ? $staropt$star$3 : /* [] */0;
  return {
          pmtd_name: name,
          pmtd_type: typ,
          pmtd_attributes: Docstrings.add_text_attrs(text, Docstrings.add_docs_attrs(docs, attrs)),
          pmtd_loc: loc
        };
}

var Mtd = {
  mk: mk$13
};

function mk$14($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, expr) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var text = $staropt$star$3 !== undefined ? $staropt$star$3 : /* [] */0;
  return {
          pmb_name: name,
          pmb_expr: expr,
          pmb_attributes: Docstrings.add_text_attrs(text, Docstrings.add_docs_attrs(docs, attrs)),
          pmb_loc: loc
        };
}

var Mb = {
  mk: mk$14
};

function mk$15($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, lid) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var override = $staropt$star$3 !== undefined ? $staropt$star$3 : /* Fresh */1;
  return {
          popen_lid: lid,
          popen_override: override,
          popen_loc: loc,
          popen_attributes: Docstrings.add_docs_attrs(docs, attrs)
        };
}

var Opn = {
  mk: mk$15
};

function mk$16($staropt$star, $staropt$star$1, $staropt$star$2, mexpr) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  return {
          pincl_mod: mexpr,
          pincl_loc: loc,
          pincl_attributes: Docstrings.add_docs_attrs(docs, attrs)
        };
}

var Incl = {
  mk: mk$16
};

function mk$17($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, pat, expr) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var text = $staropt$star$3 !== undefined ? $staropt$star$3 : /* [] */0;
  return {
          pvb_pat: pat,
          pvb_expr: expr,
          pvb_attributes: Docstrings.add_text_attrs(text, Docstrings.add_docs_attrs(docs, attrs)),
          pvb_loc: loc
        };
}

var Vb = {
  mk: mk$17
};

function mk$18($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, $staropt$star$5, name, expr) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var text = $staropt$star$3 !== undefined ? $staropt$star$3 : /* [] */0;
  var virt = $staropt$star$4 !== undefined ? $staropt$star$4 : /* Concrete */1;
  var params = $staropt$star$5 !== undefined ? $staropt$star$5 : /* [] */0;
  return {
          pci_virt: virt,
          pci_params: params,
          pci_name: name,
          pci_expr: expr,
          pci_loc: loc,
          pci_attributes: Docstrings.add_text_attrs(text, Docstrings.add_docs_attrs(docs, attrs))
        };
}

var Ci = {
  mk: mk$18
};

function mk$19($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, $staropt$star$5, $staropt$star$6, $staropt$star$7, manifest, name) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var text = $staropt$star$3 !== undefined ? $staropt$star$3 : /* [] */0;
  var params = $staropt$star$4 !== undefined ? $staropt$star$4 : /* [] */0;
  var cstrs = $staropt$star$5 !== undefined ? $staropt$star$5 : /* [] */0;
  var kind = $staropt$star$6 !== undefined ? $staropt$star$6 : /* Ptype_abstract */0;
  var priv = $staropt$star$7 !== undefined ? $staropt$star$7 : /* Public */1;
  return {
          ptype_name: name,
          ptype_params: params,
          ptype_cstrs: cstrs,
          ptype_kind: kind,
          ptype_private: priv,
          ptype_manifest: manifest,
          ptype_attributes: Docstrings.add_text_attrs(text, Docstrings.add_docs_attrs(docs, attrs)),
          ptype_loc: loc
        };
}

function constructor($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, res, name) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var info = $staropt$star$2 !== undefined ? Caml_option.valFromOption($staropt$star$2) : Docstrings.empty_info;
  var args = $staropt$star$3 !== undefined ? $staropt$star$3 : /* Pcstr_tuple */Block.__(0, [/* [] */0]);
  return {
          pcd_name: name,
          pcd_args: args,
          pcd_res: res,
          pcd_loc: loc,
          pcd_attributes: Docstrings.add_info_attrs(info, attrs)
        };
}

function field$1($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, typ) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var info = $staropt$star$2 !== undefined ? Caml_option.valFromOption($staropt$star$2) : Docstrings.empty_info;
  var mut = $staropt$star$3 !== undefined ? $staropt$star$3 : /* Immutable */0;
  return {
          pld_name: name,
          pld_mutable: mut,
          pld_type: typ,
          pld_loc: loc,
          pld_attributes: Docstrings.add_info_attrs(info, attrs)
        };
}

var Type = {
  mk: mk$19,
  constructor: constructor,
  field: field$1
};

function mk$20($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, path, constructors) {
  var attrs = $staropt$star !== undefined ? $staropt$star : /* [] */0;
  var docs = $staropt$star$1 !== undefined ? $staropt$star$1 : Docstrings.empty_docs;
  var params = $staropt$star$2 !== undefined ? $staropt$star$2 : /* [] */0;
  var priv = $staropt$star$3 !== undefined ? $staropt$star$3 : /* Public */1;
  return {
          ptyext_path: path,
          ptyext_params: params,
          ptyext_constructors: constructors,
          ptyext_private: priv,
          ptyext_attributes: Docstrings.add_docs_attrs(docs, attrs)
        };
}

function constructor$1($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, kind) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var info = $staropt$star$3 !== undefined ? Caml_option.valFromOption($staropt$star$3) : Docstrings.empty_info;
  return {
          pext_name: name,
          pext_kind: kind,
          pext_loc: loc,
          pext_attributes: Docstrings.add_docs_attrs(docs, Docstrings.add_info_attrs(info, attrs))
        };
}

function decl($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, res, name) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var info = $staropt$star$3 !== undefined ? Caml_option.valFromOption($staropt$star$3) : Docstrings.empty_info;
  var args = $staropt$star$4 !== undefined ? $staropt$star$4 : /* Pcstr_tuple */Block.__(0, [/* [] */0]);
  return {
          pext_name: name,
          pext_kind: /* Pext_decl */Block.__(0, [
              args,
              res
            ]),
          pext_loc: loc,
          pext_attributes: Docstrings.add_docs_attrs(docs, Docstrings.add_info_attrs(info, attrs))
        };
}

function rebind($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, name, lid) {
  var loc = $staropt$star !== undefined ? $staropt$star : default_loc.contents;
  var attrs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var docs = $staropt$star$2 !== undefined ? $staropt$star$2 : Docstrings.empty_docs;
  var info = $staropt$star$3 !== undefined ? Caml_option.valFromOption($staropt$star$3) : Docstrings.empty_info;
  return {
          pext_name: name,
          pext_kind: /* Pext_rebind */Block.__(1, [lid]),
          pext_loc: loc,
          pext_attributes: Docstrings.add_docs_attrs(docs, Docstrings.add_info_attrs(info, attrs))
        };
}

var Te = {
  mk: mk$20,
  constructor: constructor$1,
  decl: decl,
  rebind: rebind
};

function mk$21(self, fields) {
  return {
          pcsig_self: self,
          pcsig_fields: fields
        };
}

var Csig = {
  mk: mk$21
};

function mk$22(self, fields) {
  return {
          pcstr_self: self,
          pcstr_fields: fields
        };
}

var Cstr = {
  mk: mk$22
};

var Const = {
  $$char: $$char,
  string: string,
  integer: integer,
  $$int: $$int,
  int32: int32,
  int64: int64,
  nativeint: nativeint,
  $$float: $$float
};

var Exp = {
  mk: mk$2,
  attr: attr$2,
  ident: ident,
  constant: constant$1,
  let_: let_,
  fun_: fun_,
  function_: function_,
  apply: apply,
  match_: match_,
  try_: try_,
  tuple: tuple$2,
  construct: construct$1,
  variant: variant$2,
  record: record$1,
  field: field,
  setfield: setfield,
  array: array$1,
  ifthenelse: ifthenelse,
  sequence: sequence,
  while_: while_,
  for_: for_,
  coerce: coerce,
  constraint_: constraint_$1,
  send: send,
  new_: new_,
  setinstvar: setinstvar,
  override: override,
  letmodule: letmodule,
  letexception: letexception,
  assert_: assert_,
  lazy_: lazy_$1,
  poly: poly$1,
  object_: object_$1,
  newtype: newtype,
  pack: pack,
  open_: open_$1,
  extension: extension$2,
  unreachable: unreachable,
  $$case: $$case
};

var Ctf = {
  mk: mk$9,
  attr: attr$7,
  inherit_: inherit_,
  val_: val_,
  method_: method_,
  constraint_: constraint_$4,
  extension: extension$9,
  attribute: attribute$2,
  text: text$2
};

var Cf = {
  mk: mk$10,
  attr: attr$8,
  inherit_: inherit_$1,
  val_: val_$1,
  method_: method_$1,
  constraint_: constraint_$5,
  initializer_: initializer_,
  extension: extension$10,
  attribute: attribute$3,
  text: text$3,
  virtual_: virtual_,
  concrete: concrete
};

export {
  default_loc ,
  with_default_loc ,
  Const ,
  Typ ,
  Pat ,
  Exp ,
  Val ,
  Type ,
  Te ,
  Mty ,
  Mod ,
  Sig ,
  Str ,
  Md ,
  Mtd ,
  Mb ,
  Opn ,
  Incl ,
  Vb ,
  Cty ,
  Ctf ,
  Cl ,
  Cf ,
  Ci ,
  Csig ,
  Cstr ,
  
}
/* Location Not a pure module */
