// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Lexer from "./lexer.bs.js";
import * as Parser from "./parser.bs.js";
import * as Parsing from "./parsing.bs.js";
import * as $$Location from "./location.bs.js";
import * as Syntaxerr from "./syntaxerr.bs.js";
import * as Docstrings from "./docstrings.bs.js";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.js";

function skip_phrase(lexbuf) {
  while(true) {
    try {
      var match = Lexer.token(lexbuf);
      if (typeof match === "number" && !(match !== 25 && match !== 83)) {
        return /* () */0;
      } else {
        return skip_phrase(lexbuf);
      }
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Lexer.$$Error) {
        var tmp = exn[1];
        if (typeof tmp === "number") {
          if (tmp === /* Unterminated_string */0) {
            continue ;
          } else {
            throw exn;
          }
        } else {
          switch (tmp.tag | 0) {
            case /* Illegal_character */0 :
            case /* Unterminated_comment */2 :
            case /* Unterminated_string_in_comment */3 :
                continue ;
            default:
              throw exn;
          }
        }
      } else {
        throw exn;
      }
    }
  };
}

function maybe_skip_phrase(lexbuf) {
  if (Parsing.is_current_lookahead(/* SEMISEMI */83) || Parsing.is_current_lookahead(/* EOF */25)) {
    return /* () */0;
  } else {
    return skip_phrase(lexbuf);
  }
}

function wrap(parsing_fun, lexbuf) {
  try {
    Docstrings.init(/* () */0);
    Lexer.init(/* () */0);
    var ast = Curry._2(parsing_fun, Lexer.token, lexbuf);
    Parsing.clear_parser(/* () */0);
    Docstrings.warn_bad_docstrings(/* () */0);
    return ast;
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err[0] === Lexer.$$Error) {
      var tmp = err[1];
      if (typeof tmp === "number") {
        throw err;
      } else if (tmp.tag) {
        throw err;
      } else if ($$Location.input_name[0] === "//toplevel//") {
        skip_phrase(lexbuf);
        throw err;
      } else {
        throw err;
      }
    } else if (err[0] === Syntaxerr.$$Error) {
      if ($$Location.input_name[0] === "//toplevel//") {
        maybe_skip_phrase(lexbuf);
        throw err;
      } else {
        throw err;
      }
    } else if (err !== Parsing.Parse_error && err !== Syntaxerr.Escape_error) {
      throw err;
    }
    var loc = $$Location.curr(lexbuf);
    if ($$Location.input_name[0] === "//toplevel//") {
      maybe_skip_phrase(lexbuf);
    }
    throw [
          Syntaxerr.$$Error,
          /* Other */Block.__(5, [loc])
        ];
  }
}

function implementation(param) {
  return wrap(Parser.implementation, param);
}

function $$interface(param) {
  return wrap(Parser.$$interface, param);
}

function toplevel_phrase(param) {
  return wrap(Parser.toplevel_phrase, param);
}

function use_file(param) {
  return wrap(Parser.use_file, param);
}

function core_type(param) {
  return wrap(Parser.parse_core_type, param);
}

function expression(param) {
  return wrap(Parser.parse_expression, param);
}

function pattern(param) {
  return wrap(Parser.parse_pattern, param);
}

export {
  implementation ,
  $$interface ,
  toplevel_phrase ,
  use_file ,
  core_type ,
  expression ,
  pattern ,
  
}
/* Lexer Not a pure module */
