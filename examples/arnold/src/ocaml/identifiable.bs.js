// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as $$Map from "bs-platform/lib/es6/map.js";
import * as $$Set from "bs-platform/lib/es6/set.js";
import * as List from "bs-platform/lib/es6/list.js";
import * as Misc from "./misc.bs.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Format from "bs-platform/lib/es6/format.js";
import * as Printf from "bs-platform/lib/es6/printf.js";
import * as Hashtbl from "bs-platform/lib/es6/hashtbl.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";

function Pair(A, B) {
  var compare = function (param, param$1) {
    var c = Curry._2(A.compare, param[0], param$1[0]);
    if (c !== 0) {
      return c;
    } else {
      return Curry._2(B.compare, param[1], param$1[1]);
    }
  };
  var output = function (oc, param) {
    return Curry._4(Printf.fprintf(oc, /* Format */[
                    /* String_literal */Block.__(11, [
                        " (",
                        /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                ", ",
                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                        /* ")" */41,
                                        /* End_of_format */0
                                      ])])
                              ])])
                      ]),
                    " (%a, %a)"
                  ]), A.output, param[0], B.output, param[1]);
  };
  var hash = function (param) {
    return Hashtbl.hash(/* tuple */[
                Curry._1(A.hash, param[0]),
                Curry._1(B.hash, param[1])
              ]);
  };
  var equal = function (param, param$1) {
    if (Curry._2(A.equal, param[0], param$1[0])) {
      return Curry._2(B.equal, param[1], param$1[1]);
    } else {
      return false;
    }
  };
  var print = function (ppf, param) {
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        " (",
                        /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                ", ",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                            /* ")" */41,
                                            /* End_of_format */0
                                          ])])
                                  ])
                              ])])
                      ]),
                    " (%a, @ %a)"
                  ]), A.print, param[0], B.print, param[1]);
  };
  return {
          equal: equal,
          hash: hash,
          compare: compare,
          output: output,
          print: print
        };
}

function Make(funarg) {
  var include = $$Set.Make({
        compare: funarg.compare
      });
  var empty = include.empty;
  var add = include.add;
  var singleton = include.singleton;
  var iter = include.iter;
  var elements = include.elements;
  var output = function (oc, s) {
    Printf.fprintf(oc, /* Format */[
          /* String_literal */Block.__(11, [
              " ( ",
              /* End_of_format */0
            ]),
          " ( "
        ]);
    Curry._2(iter, (function (v) {
            return Curry._2(Printf.fprintf(oc, /* Format */[
                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                    /* " " */32,
                                    /* End_of_format */0
                                  ])]),
                            "%a "
                          ]), funarg.output, v);
          }), s);
    return Printf.fprintf(oc, /* Format */[
                /* Char_literal */Block.__(12, [
                    /* ")" */41,
                    /* End_of_format */0
                  ]),
                ")"
              ]);
  };
  var print = function (ppf, s) {
    var elts = function (ppf, s) {
      return Curry._2(iter, (function (e) {
                    return Curry._2(Format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                      ]),
                                    "@ %a"
                                  ]), funarg.print, e);
                  }), s);
    };
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<1>",
                                  /* End_of_format */0
                                ]),
                              "<1>"
                            ]]),
                        /* Char_literal */Block.__(12, [
                            /* "{" */123,
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* End_of_format */0,
                                      ""
                                    ]]),
                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* Char_literal */Block.__(12, [
                                                /* "}" */125,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])])
                              ])
                          ])
                      ]),
                    "@[<1>{@[%a@ @]}@]"
                  ]), elts, s);
  };
  var to_string = function (s) {
    return Curry._2(Format.asprintf(/* Format */[
                    /* Alpha */Block.__(15, [/* End_of_format */0]),
                    "%a"
                  ]), print, s);
  };
  var of_list = function (l) {
    if (l) {
      var q = l[1];
      var t = l[0];
      if (q) {
        return List.fold_left((function (acc, e) {
                      return Curry._2(add, e, acc);
                    }), Curry._1(singleton, t), q);
      } else {
        return Curry._1(singleton, t);
      }
    } else {
      return empty;
    }
  };
  var map = function (f, s) {
    return of_list(List.map(f, Curry._1(elements, s)));
  };
  var Set_is_empty = include.is_empty;
  var Set_mem = include.mem;
  var Set_remove = include.remove;
  var Set_union = include.union;
  var Set_inter = include.inter;
  var Set_diff = include.diff;
  var Set_compare = include.compare;
  var Set_equal = include.equal;
  var Set_subset = include.subset;
  var Set_fold = include.fold;
  var Set_for_all = include.for_all;
  var Set_exists = include.exists;
  var Set_filter = include.filter;
  var Set_partition = include.partition;
  var Set_cardinal = include.cardinal;
  var Set_min_elt = include.min_elt;
  var Set_min_elt_opt = include.min_elt_opt;
  var Set_max_elt = include.max_elt;
  var Set_max_elt_opt = include.max_elt_opt;
  var Set_choose = include.choose;
  var Set_choose_opt = include.choose_opt;
  var Set_split = include.split;
  var Set_find = include.find;
  var Set_find_opt = include.find_opt;
  var Set_find_first = include.find_first;
  var Set_find_first_opt = include.find_first_opt;
  var Set_find_last = include.find_last;
  var Set_find_last_opt = include.find_last_opt;
  var $$Set$1 = {
    empty: empty,
    is_empty: Set_is_empty,
    mem: Set_mem,
    add: add,
    singleton: singleton,
    remove: Set_remove,
    union: Set_union,
    inter: Set_inter,
    diff: Set_diff,
    compare: Set_compare,
    equal: Set_equal,
    subset: Set_subset,
    iter: iter,
    fold: Set_fold,
    for_all: Set_for_all,
    exists: Set_exists,
    filter: Set_filter,
    partition: Set_partition,
    cardinal: Set_cardinal,
    elements: elements,
    min_elt: Set_min_elt,
    min_elt_opt: Set_min_elt_opt,
    max_elt: Set_max_elt,
    max_elt_opt: Set_max_elt_opt,
    choose: Set_choose,
    choose_opt: Set_choose_opt,
    split: Set_split,
    find: Set_find,
    find_opt: Set_find_opt,
    find_first: Set_find_first,
    find_first_opt: Set_find_first_opt,
    find_last: Set_find_last,
    find_last_opt: Set_find_last_opt,
    output: output,
    print: print,
    to_string: to_string,
    of_list: of_list,
    map: map
  };
  var include$1 = $$Map.Make({
        compare: funarg.compare
      });
  var empty$1 = include$1.empty;
  var add$1 = include$1.add;
  var merge = include$1.merge;
  var union = include$1.union;
  var iter$1 = include$1.iter;
  var fold = include$1.fold;
  var bindings = include$1.bindings;
  var find = include$1.find;
  var filter_map = function (t, f) {
    return Curry._3(fold, (function (id, v, map) {
                  var match = Curry._2(f, id, v);
                  if (match !== undefined) {
                    return Curry._3(add$1, id, Caml_option.valFromOption(match), map);
                  } else {
                    return map;
                  }
                }), t, empty$1);
  };
  var of_list$1 = function (l) {
    return List.fold_left((function (map, param) {
                  return Curry._3(add$1, param[0], param[1], map);
                }), empty$1, l);
  };
  var disjoint_union = function (eq, print, m1, m2) {
    return Curry._3(union, (function (id, v1, v2) {
                  var ok = eq !== undefined ? Curry._2(eq, v1, v2) : false;
                  if (ok) {
                    return Caml_option.some(v1);
                  } else {
                    var tmp;
                    if (print !== undefined) {
                      var print$1 = print;
                      tmp = Curry._6(Format.asprintf(/* Format */[
                                /* String_literal */Block.__(11, [
                                    "Map.disjoint_union ",
                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                            " => ",
                                            /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                    " <> ",
                                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                                  ])])
                                          ])])
                                  ]),
                                "Map.disjoint_union %a => %a <> %a"
                              ]), funarg.print, id, print$1, v1, print$1, v2);
                    } else {
                      tmp = Curry._2(Format.asprintf(/* Format */[
                                /* String_literal */Block.__(11, [
                                    "Map.disjoint_union ",
                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                  ]),
                                "Map.disjoint_union %a"
                              ]), funarg.print, id);
                    }
                    return Misc.fatal_error(tmp);
                  }
                }), m1, m2);
  };
  var union_right = function (m1, m2) {
    return Curry._3(merge, (function (_id, x, y) {
                  if (x !== undefined) {
                    if (y !== undefined) {
                      return Caml_option.some(Caml_option.valFromOption(y));
                    } else {
                      return Caml_option.some(Caml_option.valFromOption(x));
                    }
                  } else if (y !== undefined) {
                    return Caml_option.some(Caml_option.valFromOption(y));
                  } else {
                    return ;
                  }
                }), m1, m2);
  };
  var union_left = function (m1, m2) {
    return union_right(m2, m1);
  };
  var union_merge = function (f, m1, m2) {
    var aux = function (param, m1, m2) {
      if (m1 !== undefined) {
        if (m2 !== undefined) {
          return Caml_option.some(Curry._2(f, Caml_option.valFromOption(m1), Caml_option.valFromOption(m2)));
        } else {
          return m1;
        }
      } else {
        return m2;
      }
    };
    return Curry._3(merge, aux, m1, m2);
  };
  var rename = function (m, v) {
    try {
      return Curry._2(find, v, m);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return v;
      } else {
        throw exn;
      }
    }
  };
  var map_keys = function (f, m) {
    return of_list$1(List.map((function (param) {
                      return /* tuple */[
                              Curry._1(f, param[0]),
                              param[1]
                            ];
                    }), Curry._1(bindings, m)));
  };
  var print$1 = function (f, ppf, s) {
    var elts = function (ppf, s) {
      return Curry._2(iter$1, (function (id, v) {
                    return Curry._4(Format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Char_literal */Block.__(12, [
                                            /* "(" */40,
                                            /* Formatting_gen */Block.__(18, [
                                                /* Open_box */Block.__(1, [/* Format */[
                                                      /* End_of_format */0,
                                                      ""
                                                    ]]),
                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@ ",
                                                            1,
                                                            0
                                                          ]),
                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                /* Close_box */0,
                                                                /* Char_literal */Block.__(12, [
                                                                    /* ")" */41,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])])
                                                      ])])
                                              ])
                                          ])
                                      ]),
                                    "@ (@[%a@ %a@])"
                                  ]), funarg.print, id, f, v);
                  }), s);
    };
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<1>",
                                  /* End_of_format */0
                                ]),
                              "<1>"
                            ]]),
                        /* Char_literal */Block.__(12, [
                            /* "{" */123,
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* End_of_format */0,
                                      ""
                                    ]]),
                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* Char_literal */Block.__(12, [
                                                /* "}" */125,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])])
                              ])
                          ])
                      ]),
                    "@[<1>{@[%a@ @]}@]"
                  ]), elts, s);
  };
  var T_set = $$Set.Make({
        compare: funarg.compare
      });
  var keys = function (map) {
    return Curry._3(fold, (function (k, param, set) {
                  return Curry._2(T_set.add, k, set);
                }), map, T_set.empty);
  };
  var data = function (t) {
    return List.map((function (prim) {
                  return prim[1];
                }), Curry._1(bindings, t));
  };
  var of_set = function (f, set) {
    return Curry._3(T_set.fold, (function (e, map) {
                  return Curry._3(add$1, e, Curry._1(f, e), map);
                }), set, empty$1);
  };
  var transpose_keys_and_data = function (map) {
    return Curry._3(fold, (function (k, v, m) {
                  return Curry._3(add$1, v, k, m);
                }), map, empty$1);
  };
  var transpose_keys_and_data_set = function (map) {
    return Curry._3(fold, (function (k, v, m) {
                  var set;
                  var exit = 0;
                  var set$1;
                  try {
                    set$1 = Curry._2(find, v, m);
                    exit = 1;
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      set = Curry._1(T_set.singleton, k);
                    } else {
                      throw exn;
                    }
                  }
                  if (exit === 1) {
                    set = Curry._2(T_set.add, k, set$1);
                  }
                  return Curry._3(add$1, v, set, m);
                }), map, empty$1);
  };
  var include$2 = Hashtbl.Make(funarg);
  var create = include$2.create;
  var add$2 = include$2.add;
  var find$1 = include$2.find;
  var fold$1 = include$2.fold;
  var include$3 = $$Map.Make({
        compare: funarg.compare
      });
  var empty$2 = include$3.empty;
  var add$3 = include$3.add;
  var iter$2 = include$3.iter;
  var cardinal = include$3.cardinal;
  var map$1 = include$3.map;
  $$Set.Make({
        compare: funarg.compare
      });
  var to_list = function (t) {
    return Curry._3(fold$1, (function (key, datum, elts) {
                  return /* :: */[
                          /* tuple */[
                            key,
                            datum
                          ],
                          elts
                        ];
                }), t, /* [] */0);
  };
  var of_list$2 = function (elts) {
    var t = Curry._1(create, 42);
    List.iter((function (param) {
            return Curry._3(add$2, t, param[0], param[1]);
          }), elts);
    return t;
  };
  var to_map = function (v) {
    return Curry._3(fold$1, add$3, v, empty$2);
  };
  var of_map = function (m) {
    var t = Curry._1(create, Curry._1(cardinal, m));
    Curry._2(iter$2, (function (k, v) {
            return Curry._3(add$2, t, k, v);
          }), m);
    return t;
  };
  var memoize = function (t, f, key) {
    try {
      return Curry._2(find$1, t, key);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var r = Curry._1(f, key);
        Curry._3(add$2, t, key, r);
        return r;
      } else {
        throw exn;
      }
    }
  };
  var map$2 = function (t, f) {
    return of_map(Curry._2(map$1, f, Curry._3(fold$1, add$3, t, empty$2)));
  };
  return {
          T: funarg,
          equal: funarg.equal,
          hash: funarg.hash,
          compare: funarg.compare,
          output: funarg.output,
          print: funarg.print,
          $$Set: $$Set$1,
          $$Map: {
            empty: empty$1,
            is_empty: include$1.is_empty,
            mem: include$1.mem,
            add: add$1,
            update: include$1.update,
            singleton: include$1.singleton,
            remove: include$1.remove,
            merge: merge,
            union: union,
            compare: include$1.compare,
            equal: include$1.equal,
            iter: iter$1,
            fold: fold,
            for_all: include$1.for_all,
            exists: include$1.exists,
            filter: include$1.filter,
            partition: include$1.partition,
            cardinal: include$1.cardinal,
            bindings: bindings,
            min_binding: include$1.min_binding,
            min_binding_opt: include$1.min_binding_opt,
            max_binding: include$1.max_binding,
            max_binding_opt: include$1.max_binding_opt,
            choose: include$1.choose,
            choose_opt: include$1.choose_opt,
            split: include$1.split,
            find: find,
            find_opt: include$1.find_opt,
            find_first: include$1.find_first,
            find_first_opt: include$1.find_first_opt,
            find_last: include$1.find_last,
            find_last_opt: include$1.find_last_opt,
            map: include$1.map,
            mapi: include$1.mapi,
            filter_map: filter_map,
            of_list: of_list$1,
            disjoint_union: disjoint_union,
            union_right: union_right,
            union_left: union_left,
            union_merge: union_merge,
            rename: rename,
            map_keys: map_keys,
            keys: keys,
            data: data,
            of_set: of_set,
            transpose_keys_and_data: transpose_keys_and_data,
            transpose_keys_and_data_set: transpose_keys_and_data_set,
            print: print$1
          },
          Tbl: {
            create: create,
            clear: include$2.clear,
            reset: include$2.reset,
            copy: include$2.copy,
            add: add$2,
            remove: include$2.remove,
            find: find$1,
            find_opt: include$2.find_opt,
            find_all: include$2.find_all,
            replace: include$2.replace,
            mem: include$2.mem,
            iter: include$2.iter,
            filter_map_inplace: include$2.filter_map_inplace,
            fold: fold$1,
            length: include$2.length,
            stats: include$2.stats,
            to_list: to_list,
            of_list: of_list$2,
            to_map: to_map,
            of_map: of_map,
            memoize: memoize,
            map: map$2
          }
        };
}

export {
  Pair ,
  Make ,
  
}
/* Misc Not a pure module */
