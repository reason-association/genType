open GenTypeCommon;

let flowExpectedError = "// $FlowExpectedError: Reason checked type sufficiently\n";

let fileHeader = (~config) =>
  switch (config.language) {
  | Flow => "/** \n * @flow strict\n * @" ++ "generated \n * @nolint\n */\n"
  | Typescript => "/* Typescript file generated by genType. */\n"
  | Untyped => "/* Untyped file generated by genType. */\n"
  };

let outputFileSuffix = (~config) =>
  switch (config.language) {
  | Flow
  | Untyped => ".re.js"
  | Typescript => ".tsx"
  };

let generatedModuleExtension = (~config) =>
  config.language == Flow ? ".re" : "";

let shimExtension = (~config) =>
  switch (config.language) {
  | Flow => ".shim.js"
  | Typescript => ".shim.ts"
  | Untyped => ".shim.not.used"
  };

let genericsString = (~typeVars) =>
  typeVars === [] ? "" : "<" ++ String.concat(",", typeVars) ++ ">";

module Indent = {
  let break = (~indent) =>
    switch (indent) {
    | None => ""
    | Some(s) => "\n" ++ s
    };

  let more = (~indent) =>
    switch (indent) {
    | None => None
    | Some(s) => Some("  " ++ s)
    };

  let heuristic = (~indent, fields) =>
    fields |> List.length > 2 && indent == None ? Some("") : indent;
};

let rec renderTyp = (~config, ~indent=None, ~inFunType, typ) =>
  switch (typ) {
  | Array(typ, arrayKind) =>
    let typIsSimple =
      switch (typ) {
      | Ident(_)
      | TypeVar(_) => true
      | _ => false
      };

    if (config.language == Typescript && typIsSimple && arrayKind == Mutable) {
      (typ |> renderTyp(~config, ~indent, ~inFunType)) ++ "[]";
    } else {
      let arrayName =
        arrayKind == Mutable ?
          "Array" :
          config.language == Flow ? "$ReadOnlyArray" : "ReadonlyArray";
      arrayName
      ++ "<"
      ++ (typ |> renderTyp(~config, ~indent, ~inFunType))
      ++ ">";
    };

  | Enum({cases, _}) =>
    cases
    |> List.map(case => case.labelJS |> EmitText.quotes)
    |> String.concat(" | ")

  | Function({typeVars, argTypes, retType}) =>
    renderFunType(~config, ~indent, ~inFunType, ~typeVars, argTypes, retType)

  | GroupOfLabeledArgs(fields)
  | Object(fields)
  | Record(fields) =>
    let indent1 = fields |> Indent.heuristic(~indent);
    fields |> renderFields(~config, ~indent=indent1, ~inFunType);

  | Ident(identPath, typeArguments) =>
    identPath
    ++ genericsString(
         ~typeVars=
           typeArguments |> List.map(renderTyp(~config, ~indent, ~inFunType)),
       )
  | Nullable(typ)
  | Option(typ) =>
    switch (config.language) {
    | Flow
    | Untyped => "?" ++ (typ |> renderTyp(~config, ~indent, ~inFunType))
    | Typescript =>
      "(null | undefined | "
      ++ (typ |> renderTyp(~config, ~indent, ~inFunType))
      ++ ")"
    }
  | Tuple(innerTypes) =>
    "["
    ++ (
      innerTypes
      |> List.map(renderTyp(~config, ~indent, ~inFunType))
      |> String.concat(", ")
    )
    ++ "]"
  | TypeVar(s) => s
  }
and renderField =
    (~config, ~indent, ~inFunType, {name: lbl, optional, mutable_, typ}) => {
  let optMarker = optional === Optional ? "?" : "";
  let mutMarker =
    mutable_ == Immutable ? config.language == Flow ? "+" : "readonly " : "";
  Indent.break(~indent)
  ++ mutMarker
  ++ lbl
  ++ optMarker
  ++ ": "
  ++ (typ |> renderTyp(~config, ~indent, ~inFunType));
}
and renderFields = (~config, ~indent, ~inFunType, fields) => {
  let indent1 = Indent.more(~indent);
  (config.language == Flow ? "{|" : "{")
  ++ String.concat(
       ", ",
       List.map(renderField(~config, ~indent=indent1, ~inFunType), fields),
     )
  ++ Indent.break(~indent)
  ++ (config.language == Flow ? "|}" : "}");
}
and renderFunType =
    (~config, ~indent, ~inFunType, ~typeVars, argTypes, retType) =>
  (inFunType ? "(" : "")
  ++ genericsString(~typeVars)
  ++ "("
  ++ String.concat(
       ", ",
       List.mapi(
         (i, t) => {
           let parameterName =
             config.language == Flow ?
               "" : "_" ++ string_of_int(i + 1) ++ ":";
           parameterName
           ++ (t |> renderTyp(~config, ~indent, ~inFunType=true));
         },
         argTypes,
       ),
     )
  ++ ") => "
  ++ (retType |> renderTyp(~config, ~indent, ~inFunType))
  ++ (inFunType ? ")" : "");

let typToString = (~config, typ) =>
  typ |> renderTyp(~config, ~inFunType=false);

let ofType = (~config, ~typ, s) =>
  config.language == Untyped ? s : s ++ ": " ++ (typ |> typToString(~config));

let emitExportConst_ =
    (~early, ~comment="", ~emitters, ~name, ~typ, ~config, line) =>
  (comment == "" ? comment : "// " ++ comment ++ "\n")
  ++ (
    switch (config.module_, config.language) {
    | (_, Typescript)
    | (ES6, _) =>
      "export const " ++ (name |> ofType(~config, ~typ)) ++ " = " ++ line
    | (CommonJS, _) =>
      "const "
      ++ (name |> ofType(~config, ~typ))
      ++ " = "
      ++ line
      ++ ";\nexports."
      ++ name
      ++ " = "
      ++ name
    }
  )
  |> (early ? Emitters.exportEarly : Emitters.export)(~emitters);

let emitExportConst = emitExportConst_(~early=false);

let emitExportConstEarly = emitExportConst_(~early=true);

let emitExportConstMany = (~emitters, ~name, ~typ, ~config, lines) =>
  lines
  |> String.concat("\n")
  |> emitExportConst(~emitters, ~name, ~typ, ~config);

let emitExportFunction =
    (~early, ~comment="", ~emitters, ~name, ~config, line) =>
  (comment == "" ? comment : "// " ++ comment ++ "\n")
  ++ (
    switch (config.module_, config.language) {
    | (_, Typescript)
    | (ES6, _) => "export function " ++ name ++ line
    | (CommonJS, _) =>
      "function " ++ name ++ line ++ ";\nexports." ++ name ++ " = " ++ name
    }
  )
  |> (early ? Emitters.exportEarly : Emitters.export)(~emitters);

let emitExportDefault = (~emitters, ~config, name) =>
  switch (config.module_, config.language) {
  | (_, Typescript)
  | (ES6, _) =>
    "export default " ++ name ++ ";" |> Emitters.export(~emitters)
  | (CommonJS, _) =>
    "exports.default = " ++ name ++ ";" |> Emitters.export(~emitters)
  };

let emitExportType =
    (
      ~early=false,
      ~emitters,
      ~config,
      ~opaque,
      ~typeVars,
      ~optTyp,
      resolvedTypeName,
    ) => {
  let export = early ? Emitters.exportEarly : Emitters.export;
  let typeParamsString = genericsString(~typeVars);

  switch (config.language) {
  | Flow =>
    switch (optTyp) {
    | Some(typ) =>
      "export"
      ++ (opaque ? " opaque " : " ")
      ++ "type "
      ++ resolvedTypeName
      ++ typeParamsString
      ++ " = "
      ++ ((opaque ? mixedOrUnknown(~config) : typ) |> typToString(~config))
      ++ ";"
      |> export(~emitters)
    | None =>
      "export"
      ++ (opaque ? " opaque " : " ")
      ++ "type "
      ++ (resolvedTypeName |> EmitText.brackets)
      ++ ";"
      |> export(~emitters)
    }
  | Typescript =>
    if (opaque) {
      /* Represent an opaque type as an absract class with a field called 'opaque'.
         Any type parameters must occur in the type of opaque, so that different
         instantiations are considered different types. */
      let typeOfOpaqueField =
        typeVars == [] ? "any" : typeVars |> String.concat(" | ");
      "// tslint:disable-next-line:max-classes-per-file \n"
      ++ (
        String.capitalize(resolvedTypeName) != resolvedTypeName ?
          "// tslint:disable-next-line:class-name\n" : ""
      )
      ++ "export abstract class "
      ++ resolvedTypeName
      ++ typeParamsString
      ++ " { protected opaque!: "
      ++ typeOfOpaqueField
      ++ " }; /* simulate opaque types */"
      |> export(~emitters);
    } else {
      "// tslint:disable-next-line:interface-over-type-literal\n"
      ++ "export type "
      ++ resolvedTypeName
      ++ typeParamsString
      ++ " = "
      ++ (
        switch (optTyp) {
        | Some(typ) => typ |> typToString(~config)
        | None => resolvedTypeName
        }
      )
      ++ ";"
      |> export(~emitters);
    }
  | Untyped => emitters
  };
};

let emitExportVariantType =
    (~emitters, ~config, ~name, ~typeParams, ~variants: list(variant)) =>
  switch (config.language) {
  | Flow
  | Typescript =>
    "export type "
    ++ name
    ++ genericsString(
         ~typeVars=typeParams |> List.map(typToString(~config)),
       )
    ++ " =\n  | "
    ++ (
      variants
      |> List.map(({name, params}) =>
           Ident(name, params) |> typToString(~config)
         )
      |> String.concat("\n  | ")
    )
    ++ ";"
    |> Emitters.export(~emitters)
  | Untyped => emitters
  };

let emitImportValueAsEarly = (~emitters, ~name, ~nameAs, importPath) =>
  "import "
  ++ (
    switch (nameAs) {
    | Some(nameAs) => "{" ++ name ++ " as " ++ nameAs ++ "}"
    | None => name
    }
  )
  ++ " from"
  ++ "'"
  ++ (importPath |> ImportPath.toString)
  ++ "';"
  |> Emitters.requireEarly(~emitters);

let emitRequire =
    (~early, ~emitters, ~config, ~moduleName, ~strict, importPath) => {
  let commentBeforeRequire =
    switch (config.language) {
    | Typescript => "// tslint:disable-next-line:no-var-requires\n"
    | Flow => strict ? "" : flowExpectedError
    | Untyped => ""
    };
  commentBeforeRequire
  ++ "const "
  ++ ModuleName.toString(moduleName)
  ++ " = require('"
  ++ (importPath |> ImportPath.toString)
  ++ "');"
  |> (early ? Emitters.requireEarly : Emitters.require)(~emitters);
};

let require = (~early) => early ? Emitters.requireEarly : Emitters.require;

let emitRequireReact = (~early, ~emitters, ~config) =>
  switch (config.language) {
  | Flow =>
    emitRequire(
      ~early,
      ~emitters,
      ~config,
      ~moduleName=ModuleName.react,
      ~strict=false,
      ImportPath.react,
    )
  | Typescript =>
    "import * as React from 'react';" |> require(~early, ~emitters)
  | Untyped => emitters
  };

let reactComponentType = (~config, ~propsTypeName) =>
  Ident(
    config.language == Flow ? "React$ComponentType" : "React.ComponentClass",
    [Ident(propsTypeName, [])],
  );

let componentExportName = (~config, ~fileName, ~moduleName) =>
  switch (config.language) {
  | Flow =>
    fileName == moduleName ? "component" : moduleName |> ModuleName.toString
  | _ => moduleName |> ModuleName.toString
  };

let emitImportTypeAs =
    (~emitters, ~config, ~typeName, ~asTypeName, ~importPath) =>
  switch (config.language) {
  | Flow
  | Typescript =>
    "import "
    ++ (config.language == Flow ? "type " : "")
    ++ "{"
    ++ typeName
    ++ (
      switch (asTypeName) {
      | Some(asT) => " as " ++ asT
      | None => ""
      }
    )
    ++ "} from '"
    ++ (importPath |> ImportPath.toString)
    ++ "';"
    |> Emitters.import(~emitters)
  | Untyped => emitters
  };

let ofTypeAny = (~config, s) =>
  config.language == Typescript ? s ++ ": any" : s;